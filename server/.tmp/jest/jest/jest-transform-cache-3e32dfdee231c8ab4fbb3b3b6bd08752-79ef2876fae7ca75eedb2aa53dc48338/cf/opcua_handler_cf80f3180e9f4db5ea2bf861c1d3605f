2bf64c712d170457e5f007fe7c2198b9
// server/handlers/opcua_handler.js
const {
  OPCUAClient,
  AttributeIds,
  MessageSecurityMode,
  SecurityPolicy,
  Variant,
  VariantArrayType,
  DataType
} = require('node-opcua');
class OPCUAHandler {
  constructor(connectionId, config = {}) {
    this.connectionId = connectionId;
    this.config = config;
    this.client = null;
    this.session = null;
    this.isConnected = false;
    // Cache of node metadata: { dataType, valueRank, arrayDimensions }
    this._metaCache = new Map();
  }
  async connect() {
    const endpointUrl = this.config.endpointUrl;
    if (!endpointUrl) throw new Error('OPC UA endpointUrl is required');
    const client = OPCUAClient.create({
      applicationName: 'Universal Test Client',
      securityMode: MessageSecurityMode.None,
      securityPolicy: SecurityPolicy.None,
      endpointMustExist: false,
      connectionStrategy: {
        initialDelay: 250,
        maxRetry: 1
      }
    });
    const timeoutMs = Number(this.config.timeoutMs || 5000);
    const connectPromise = client.connect(endpointUrl);
    const timed = new Promise((_, reject) => setTimeout(() => reject(new Error('OPC UA connect timeout')), timeoutMs));
    await Promise.race([connectPromise, timed]);
    const session = await client.createSession();
    this.client = client;
    this.session = session;
    this.isConnected = true;
    return {
      success: true
    };
  }
  async disconnect() {
    try {
      if (this.session) await this.session.close();
    } catch {}
    try {
      if (this.client) await this.client.disconnect();
    } catch {}
    this.client = null;
    this.session = null;
    this.isConnected = false;
    this._metaCache.clear();
    return {
      success: true
    };
  }
  async browse(nodeId = 'RootFolder') {
    if (!this.session) throw new Error('Not connected');
    const result = await this.session.browse(nodeId);
    return {
      success: true,
      data: result.references || []
    };
  }
  async read(nodes) {
    if (!this.session) throw new Error('Not connected');
    const nodesToRead = (Array.isArray(nodes) ? nodes : [nodes]).map(n => ({
      nodeId: n,
      attributeId: AttributeIds.Value
    }));
    const dataValues = await this.session.read(nodesToRead);
    return {
      success: true,
      data: dataValues
    };
  }
  async write(nodeId, value, dataType = null) {
    if (!this.session) throw new Error('Not connected');
    if (!nodeId) throw new Error('nodeId is required');

    // Fetch and cache node meta (datatype, valueRank, arrayDimensions)
    const meta = await this._getNodeMeta(nodeId);

    // Choose dataType: explicit > meta-inferred > heuristic
    let dt = dataType ?? meta?.dataType;

    // Validate rank/shape before coercion/write
    const rankCheck = this._validateRankAndShape(value, meta);
    if (!rankCheck.ok) {
      return {
        success: false,
        error: rankCheck.error
      };
    }
    const variant = this._coerceVariant(value, dt);
    const statusCode = await this.session.writeSingleNode(nodeId, variant);
    const scStr = statusCode?.name || String(statusCode || '');
    const ok = !!statusCode && (statusCode.value === 0 || scStr.includes('Good'));
    return {
      success: ok,
      statusCode: scStr
    };
  }
  async _inferDataTypeForNode(nodeId) {
    const dv = await this.session.read({
      nodeId,
      attributeId: AttributeIds.DataType
    });
    const dtNodeId = dv?.value?.value;
    if (dtNodeId && dtNodeId.namespace === 0 && typeof dtNodeId.value === 'number') {
      return dtNodeId.value;
    }
    // Fallback: read current value's variant to infer dataType
    const valDV = await this.session.read({
      nodeId,
      attributeId: AttributeIds.Value
    });
    const vt = valDV?.value?.dataType;
    if (typeof vt === 'number') return vt;
    return undefined;
  }
  async _getNodeMeta(nodeId) {
    if (this._metaCache.has(nodeId)) return this._metaCache.get(nodeId);
    const toRead = [{
      nodeId,
      attributeId: AttributeIds.DataType
    }, {
      nodeId,
      attributeId: AttributeIds.ValueRank
    }, {
      nodeId,
      attributeId: AttributeIds.ArrayDimensions
    }];
    const [dtDV, rankDV, dimsDV] = await this.session.read(toRead);
    const meta = {
      dataType: dtDV?.value?.value && dtDV.value.value.namespace === 0 ? dtDV.value.value.value : undefined,
      valueRank: typeof rankDV?.value?.value === 'number' ? rankDV.value.value : -1,
      arrayDimensions: Array.isArray(dimsDV?.value?.value) ? dimsDV.value.value : []
    };
    this._metaCache.set(nodeId, meta);
    return meta;
  }
  _validateRankAndShape(value, meta) {
    if (!meta) return {
      ok: true
    };
    const rank = meta.valueRank;
    if (rank == null || rank === -1) {
      // Scalar expected
      if (Array.isArray(value)) return {
        ok: false,
        error: 'BadTypeMismatch: scalar expected'
      };
      return {
        ok: true
      };
    }
    // Array expected (rank >= 1)
    if (!Array.isArray(value)) return {
      ok: false,
      error: 'BadTypeMismatch: array expected'
    };
    // Validate dimension lengths if provided (zeros mean unspecified)
    if (Array.isArray(meta.arrayDimensions) && meta.arrayDimensions.length > 0) {
      const fixedDims = meta.arrayDimensions.every(d => typeof d === 'number' && d > 0);
      if (fixedDims && meta.arrayDimensions.length === 1) {
        if (value.length !== meta.arrayDimensions[0]) {
          return {
            ok: false,
            error: `BadTypeMismatch: expected length ${meta.arrayDimensions[0]}`
          };
        }
      }
      // For multi-dim arrays, validation would need nested shapes; omitted for now.
    }
    return {
      ok: true
    };
  }
  _coerceVariant(val, dt) {
    // If val is already a Variant, pass through
    if (val && val.dataType !== undefined && val.value !== undefined) {
      return val;
    }
    const map = {
      Boolean: DataType.Boolean,
      Int16: DataType.Int16,
      Int32: DataType.Int32,
      Int64: DataType.Int64,
      UInt16: DataType.UInt16,
      UInt32: DataType.UInt32,
      UInt64: DataType.UInt64,
      Float: DataType.Float,
      Double: DataType.Double,
      String: DataType.String,
      DateTime: DataType.DateTime,
      ByteString: DataType.ByteString
    };
    let dataType = dt && map[dt] !== undefined ? map[dt] : undefined;

    // Infer when not provided
    if (dataType === undefined) {
      if (Array.isArray(val)) {
        // Infer from first element
        const first = val[0];
        if (typeof first === 'number') dataType = Number.isInteger(first) ? DataType.Int32 : DataType.Double;else if (typeof first === 'boolean') dataType = DataType.Boolean;else dataType = DataType.String;
        return new Variant({
          dataType,
          arrayType: VariantArrayType.Array,
          value: val
        });
      }
      switch (typeof val) {
        case 'number':
          dataType = Number.isInteger(val) ? DataType.Int32 : DataType.Double;
          break;
        case 'boolean':
          dataType = DataType.Boolean;
          break;
        case 'string':
          dataType = DataType.String;
          break;
        default:
          // Fallback to String
          dataType = DataType.String;
      }
      return new Variant({
        dataType,
        value: val
      });
    }

    // Respect explicit dataType, support arrays with element coercion
    if (Array.isArray(val)) {
      const coercedArr = val.map(v => this._coerceJs(v, dataType));
      // For numeric array types, use TypedArrays to satisfy node-opcua encoders
      const toTyped = (arr, dt) => {
        switch (dt) {
          case DataType.Int16:
            return Int16Array.from(arr);
          case DataType.Int32:
            return Int32Array.from(arr);
          case DataType.Int64:
            return BigInt64Array.from(arr.map(x => BigInt(Math.trunc(x))));
          case DataType.UInt16:
            return Uint16Array.from(arr);
          case DataType.UInt32:
            return Uint32Array.from(arr);
          case DataType.UInt64:
            return BigUint64Array.from(arr.map(x => BigInt(Math.trunc(x))));
          case DataType.Float:
            return Float32Array.from(arr);
          case DataType.Double:
            return Float64Array.from(arr);
          default:
            return arr;
        }
      };
      const typed = toTyped(coercedArr, dataType);
      return new Variant({
        dataType,
        arrayType: VariantArrayType.Array,
        value: typed
      });
    }
    const coerced = this._coerceJs(val, dataType);
    return new Variant({
      dataType,
      value: coerced
    });
  }
  _coerceJs(val, dataType) {
    // If dataType is a numeric built-in id (0..n), map it to enum constant
    if (typeof dataType === 'number') {
      // dataType already numeric; fall-through
    }
    switch (dataType) {
      case DataType.Boolean:
        if (typeof val === 'string') return val.toLowerCase() === 'true';
        return Boolean(val);
      case DataType.Int16:
      case DataType.Int32:
      case DataType.Int64:
      case DataType.UInt16:
      case DataType.UInt32:
      case DataType.UInt64:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? Math.trunc(n) : val;
        }
        return Math.trunc(val);
      case DataType.Float:
      case DataType.Double:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? n : val;
        }
        return Number(val);
      case DataType.String:
        return String(val);
      default:
        return val;
    }
  }
}
module.exports = OPCUAHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPUENVQUNsaWVudCIsIkF0dHJpYnV0ZUlkcyIsIk1lc3NhZ2VTZWN1cml0eU1vZGUiLCJTZWN1cml0eVBvbGljeSIsIlZhcmlhbnQiLCJWYXJpYW50QXJyYXlUeXBlIiwiRGF0YVR5cGUiLCJyZXF1aXJlIiwiT1BDVUFIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uSWQiLCJjb25maWciLCJjbGllbnQiLCJzZXNzaW9uIiwiaXNDb25uZWN0ZWQiLCJfbWV0YUNhY2hlIiwiTWFwIiwiY29ubmVjdCIsImVuZHBvaW50VXJsIiwiRXJyb3IiLCJjcmVhdGUiLCJhcHBsaWNhdGlvbk5hbWUiLCJzZWN1cml0eU1vZGUiLCJOb25lIiwic2VjdXJpdHlQb2xpY3kiLCJlbmRwb2ludE11c3RFeGlzdCIsImNvbm5lY3Rpb25TdHJhdGVneSIsImluaXRpYWxEZWxheSIsIm1heFJldHJ5IiwidGltZW91dE1zIiwiTnVtYmVyIiwiY29ubmVjdFByb21pc2UiLCJ0aW1lZCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsInJhY2UiLCJjcmVhdGVTZXNzaW9uIiwic3VjY2VzcyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImNsZWFyIiwiYnJvd3NlIiwibm9kZUlkIiwicmVzdWx0IiwiZGF0YSIsInJlZmVyZW5jZXMiLCJyZWFkIiwibm9kZXMiLCJub2Rlc1RvUmVhZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm4iLCJhdHRyaWJ1dGVJZCIsIlZhbHVlIiwiZGF0YVZhbHVlcyIsIndyaXRlIiwidmFsdWUiLCJkYXRhVHlwZSIsIm1ldGEiLCJfZ2V0Tm9kZU1ldGEiLCJkdCIsInJhbmtDaGVjayIsIl92YWxpZGF0ZVJhbmtBbmRTaGFwZSIsIm9rIiwiZXJyb3IiLCJ2YXJpYW50IiwiX2NvZXJjZVZhcmlhbnQiLCJzdGF0dXNDb2RlIiwid3JpdGVTaW5nbGVOb2RlIiwic2NTdHIiLCJuYW1lIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJfaW5mZXJEYXRhVHlwZUZvck5vZGUiLCJkdiIsImR0Tm9kZUlkIiwibmFtZXNwYWNlIiwidmFsRFYiLCJ2dCIsInVuZGVmaW5lZCIsImhhcyIsImdldCIsInRvUmVhZCIsIlZhbHVlUmFuayIsIkFycmF5RGltZW5zaW9ucyIsImR0RFYiLCJyYW5rRFYiLCJkaW1zRFYiLCJ2YWx1ZVJhbmsiLCJhcnJheURpbWVuc2lvbnMiLCJzZXQiLCJyYW5rIiwibGVuZ3RoIiwiZml4ZWREaW1zIiwiZXZlcnkiLCJkIiwidmFsIiwiQm9vbGVhbiIsIkludDE2IiwiSW50MzIiLCJJbnQ2NCIsIlVJbnQxNiIsIlVJbnQzMiIsIlVJbnQ2NCIsIkZsb2F0IiwiRG91YmxlIiwiRGF0ZVRpbWUiLCJCeXRlU3RyaW5nIiwiZmlyc3QiLCJpc0ludGVnZXIiLCJhcnJheVR5cGUiLCJjb2VyY2VkQXJyIiwidiIsIl9jb2VyY2VKcyIsInRvVHlwZWQiLCJhcnIiLCJJbnQxNkFycmF5IiwiZnJvbSIsIkludDMyQXJyYXkiLCJCaWdJbnQ2NEFycmF5IiwieCIsIkJpZ0ludCIsIk1hdGgiLCJ0cnVuYyIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJCaWdVaW50NjRBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsInR5cGVkIiwiY29lcmNlZCIsInRvTG93ZXJDYXNlIiwiaXNGaW5pdGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZXMiOlsib3BjdWFfaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzZXJ2ZXIvaGFuZGxlcnMvb3BjdWFfaGFuZGxlci5qc1xyXG5jb25zdCB7IE9QQ1VBQ2xpZW50LCBBdHRyaWJ1dGVJZHMsIE1lc3NhZ2VTZWN1cml0eU1vZGUsIFNlY3VyaXR5UG9saWN5LCBWYXJpYW50LCBWYXJpYW50QXJyYXlUeXBlLCBEYXRhVHlwZSB9ID0gcmVxdWlyZSgnbm9kZS1vcGN1YScpO1xyXG5cclxuY2xhc3MgT1BDVUFIYW5kbGVyIHtcclxuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uSWQsIGNvbmZpZyA9IHt9KSB7XHJcbiAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcclxuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgdGhpcy5jbGllbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcclxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgIC8vIENhY2hlIG9mIG5vZGUgbWV0YWRhdGE6IHsgZGF0YVR5cGUsIHZhbHVlUmFuaywgYXJyYXlEaW1lbnNpb25zIH1cclxuICAgIHRoaXMuX21ldGFDYWNoZSA9IG5ldyBNYXAoKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGNvbm5lY3QoKSB7XHJcbiAgICBjb25zdCBlbmRwb2ludFVybCA9IHRoaXMuY29uZmlnLmVuZHBvaW50VXJsO1xyXG4gICAgaWYgKCFlbmRwb2ludFVybCkgdGhyb3cgbmV3IEVycm9yKCdPUEMgVUEgZW5kcG9pbnRVcmwgaXMgcmVxdWlyZWQnKTtcclxuXHJcbiAgICBjb25zdCBjbGllbnQgPSBPUENVQUNsaWVudC5jcmVhdGUoe1xyXG4gICAgICBhcHBsaWNhdGlvbk5hbWU6ICdVbml2ZXJzYWwgVGVzdCBDbGllbnQnLFxyXG4gICAgICBzZWN1cml0eU1vZGU6IE1lc3NhZ2VTZWN1cml0eU1vZGUuTm9uZSxcclxuICAgICAgc2VjdXJpdHlQb2xpY3k6IFNlY3VyaXR5UG9saWN5Lk5vbmUsXHJcbiAgICAgIGVuZHBvaW50TXVzdEV4aXN0OiBmYWxzZSxcclxuICAgICAgY29ubmVjdGlvblN0cmF0ZWd5OiB7IGluaXRpYWxEZWxheTogMjUwLCBtYXhSZXRyeTogMSB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB0aW1lb3V0TXMgPSBOdW1iZXIodGhpcy5jb25maWcudGltZW91dE1zIHx8IDUwMDApO1xyXG4gICAgY29uc3QgY29ubmVjdFByb21pc2UgPSBjbGllbnQuY29ubmVjdChlbmRwb2ludFVybCk7XHJcbiAgICBjb25zdCB0aW1lZCA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignT1BDIFVBIGNvbm5lY3QgdGltZW91dCcpKSwgdGltZW91dE1zKSk7XHJcbiAgICBhd2FpdCBQcm9taXNlLnJhY2UoW2Nvbm5lY3RQcm9taXNlLCB0aW1lZF0pO1xyXG5cclxuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjbGllbnQuY3JlYXRlU2Vzc2lvbigpO1xyXG5cclxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xyXG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcclxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XHJcbiAgICB0cnkgeyBpZiAodGhpcy5zZXNzaW9uKSBhd2FpdCB0aGlzLnNlc3Npb24uY2xvc2UoKTsgfSBjYXRjaCB7fVxyXG4gICAgdHJ5IHsgaWYgKHRoaXMuY2xpZW50KSBhd2FpdCB0aGlzLmNsaWVudC5kaXNjb25uZWN0KCk7IH0gY2F0Y2gge31cclxuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9tZXRhQ2FjaGUuY2xlYXIoKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGJyb3dzZShub2RlSWQgPSAnUm9vdEZvbGRlcicpIHtcclxuICAgIGlmICghdGhpcy5zZXNzaW9uKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5icm93c2Uobm9kZUlkKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC5yZWZlcmVuY2VzIHx8IFtdIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyByZWFkKG5vZGVzKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XHJcbiAgICBjb25zdCBub2Rlc1RvUmVhZCA9IChBcnJheS5pc0FycmF5KG5vZGVzKSA/IG5vZGVzIDogW25vZGVzXSkubWFwKChuKSA9PiAoeyBub2RlSWQ6IG4sIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuVmFsdWUgfSkpO1xyXG4gICAgY29uc3QgZGF0YVZhbHVlcyA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5yZWFkKG5vZGVzVG9SZWFkKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IGRhdGFWYWx1ZXMgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHdyaXRlKG5vZGVJZCwgdmFsdWUsIGRhdGFUeXBlID0gbnVsbCkge1xyXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xyXG4gICAgaWYgKCFub2RlSWQpIHRocm93IG5ldyBFcnJvcignbm9kZUlkIGlzIHJlcXVpcmVkJyk7XHJcblxyXG4gICAgLy8gRmV0Y2ggYW5kIGNhY2hlIG5vZGUgbWV0YSAoZGF0YXR5cGUsIHZhbHVlUmFuaywgYXJyYXlEaW1lbnNpb25zKVxyXG4gICAgY29uc3QgbWV0YSA9IGF3YWl0IHRoaXMuX2dldE5vZGVNZXRhKG5vZGVJZCk7XHJcblxyXG4gICAgLy8gQ2hvb3NlIGRhdGFUeXBlOiBleHBsaWNpdCA+IG1ldGEtaW5mZXJyZWQgPiBoZXVyaXN0aWNcclxuICAgIGxldCBkdCA9IGRhdGFUeXBlID8/IG1ldGE/LmRhdGFUeXBlO1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIHJhbmsvc2hhcGUgYmVmb3JlIGNvZXJjaW9uL3dyaXRlXHJcbiAgICBjb25zdCByYW5rQ2hlY2sgPSB0aGlzLl92YWxpZGF0ZVJhbmtBbmRTaGFwZSh2YWx1ZSwgbWV0YSk7XHJcbiAgICBpZiAoIXJhbmtDaGVjay5vaykge1xyXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJhbmtDaGVjay5lcnJvciB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHZhcmlhbnQgPSB0aGlzLl9jb2VyY2VWYXJpYW50KHZhbHVlLCBkdCk7XHJcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gYXdhaXQgdGhpcy5zZXNzaW9uLndyaXRlU2luZ2xlTm9kZShub2RlSWQsIHZhcmlhbnQpO1xyXG4gICAgY29uc3Qgc2NTdHIgPSBzdGF0dXNDb2RlPy5uYW1lIHx8IFN0cmluZyhzdGF0dXNDb2RlIHx8ICcnKTtcclxuICAgIGNvbnN0IG9rID0gISFzdGF0dXNDb2RlICYmIChzdGF0dXNDb2RlLnZhbHVlID09PSAwIHx8IHNjU3RyLmluY2x1ZGVzKCdHb29kJykpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2Vzczogb2ssIHN0YXR1c0NvZGU6IHNjU3RyIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBfaW5mZXJEYXRhVHlwZUZvck5vZGUobm9kZUlkKSB7XHJcbiAgICBjb25zdCBkdiA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5yZWFkKHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLkRhdGFUeXBlIH0pO1xyXG4gICAgY29uc3QgZHROb2RlSWQgPSBkdj8udmFsdWU/LnZhbHVlO1xyXG4gICAgaWYgKGR0Tm9kZUlkICYmIGR0Tm9kZUlkLm5hbWVzcGFjZSA9PT0gMCAmJiB0eXBlb2YgZHROb2RlSWQudmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIHJldHVybiBkdE5vZGVJZC52YWx1ZTtcclxuICAgIH1cclxuICAgIC8vIEZhbGxiYWNrOiByZWFkIGN1cnJlbnQgdmFsdWUncyB2YXJpYW50IHRvIGluZmVyIGRhdGFUeXBlXHJcbiAgICBjb25zdCB2YWxEViA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5yZWFkKHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLlZhbHVlIH0pO1xyXG4gICAgY29uc3QgdnQgPSB2YWxEVj8udmFsdWU/LmRhdGFUeXBlO1xyXG4gICAgaWYgKHR5cGVvZiB2dCA9PT0gJ251bWJlcicpIHJldHVybiB2dDtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBhc3luYyBfZ2V0Tm9kZU1ldGEobm9kZUlkKSB7XHJcbiAgICBpZiAodGhpcy5fbWV0YUNhY2hlLmhhcyhub2RlSWQpKSByZXR1cm4gdGhpcy5fbWV0YUNhY2hlLmdldChub2RlSWQpO1xyXG4gICAgY29uc3QgdG9SZWFkID0gW1xyXG4gICAgICB7IG5vZGVJZCwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5EYXRhVHlwZSB9LFxyXG4gICAgICB7IG5vZGVJZCwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5WYWx1ZVJhbmsgfSxcclxuICAgICAgeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuQXJyYXlEaW1lbnNpb25zIH0sXHJcbiAgICBdO1xyXG4gICAgY29uc3QgW2R0RFYsIHJhbmtEViwgZGltc0RWXSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi5yZWFkKHRvUmVhZCk7XHJcbiAgICBjb25zdCBtZXRhID0ge1xyXG4gICAgICBkYXRhVHlwZTogKGR0RFY/LnZhbHVlPy52YWx1ZSAmJiBkdERWLnZhbHVlLnZhbHVlLm5hbWVzcGFjZSA9PT0gMCkgPyBkdERWLnZhbHVlLnZhbHVlLnZhbHVlIDogdW5kZWZpbmVkLFxyXG4gICAgICB2YWx1ZVJhbms6IHR5cGVvZiByYW5rRFY/LnZhbHVlPy52YWx1ZSA9PT0gJ251bWJlcicgPyByYW5rRFYudmFsdWUudmFsdWUgOiAtMSxcclxuICAgICAgYXJyYXlEaW1lbnNpb25zOiBBcnJheS5pc0FycmF5KGRpbXNEVj8udmFsdWU/LnZhbHVlKSA/IGRpbXNEVi52YWx1ZS52YWx1ZSA6IFtdLFxyXG4gICAgfTtcclxuICAgIHRoaXMuX21ldGFDYWNoZS5zZXQobm9kZUlkLCBtZXRhKTtcclxuICAgIHJldHVybiBtZXRhO1xyXG4gIH1cclxuXHJcbiAgX3ZhbGlkYXRlUmFua0FuZFNoYXBlKHZhbHVlLCBtZXRhKSB7XHJcbiAgICBpZiAoIW1ldGEpIHJldHVybiB7IG9rOiB0cnVlIH07XHJcbiAgICBjb25zdCByYW5rID0gbWV0YS52YWx1ZVJhbms7XHJcbiAgICBpZiAocmFuayA9PSBudWxsIHx8IHJhbmsgPT09IC0xKSB7XHJcbiAgICAgIC8vIFNjYWxhciBleHBlY3RlZFxyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdCYWRUeXBlTWlzbWF0Y2g6IHNjYWxhciBleHBlY3RlZCcgfTtcclxuICAgICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxuICAgIH1cclxuICAgIC8vIEFycmF5IGV4cGVjdGVkIChyYW5rID49IDEpXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnQmFkVHlwZU1pc21hdGNoOiBhcnJheSBleHBlY3RlZCcgfTtcclxuICAgIC8vIFZhbGlkYXRlIGRpbWVuc2lvbiBsZW5ndGhzIGlmIHByb3ZpZGVkICh6ZXJvcyBtZWFuIHVuc3BlY2lmaWVkKVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YS5hcnJheURpbWVuc2lvbnMpICYmIG1ldGEuYXJyYXlEaW1lbnNpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgZml4ZWREaW1zID0gbWV0YS5hcnJheURpbWVuc2lvbnMuZXZlcnkoZCA9PiB0eXBlb2YgZCA9PT0gJ251bWJlcicgJiYgZCA+IDApO1xyXG4gICAgICBpZiAoZml4ZWREaW1zICYmIG1ldGEuYXJyYXlEaW1lbnNpb25zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IG1ldGEuYXJyYXlEaW1lbnNpb25zWzBdKSB7XHJcbiAgICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgQmFkVHlwZU1pc21hdGNoOiBleHBlY3RlZCBsZW5ndGggJHttZXRhLmFycmF5RGltZW5zaW9uc1swXX1gIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIC8vIEZvciBtdWx0aS1kaW0gYXJyYXlzLCB2YWxpZGF0aW9uIHdvdWxkIG5lZWQgbmVzdGVkIHNoYXBlczsgb21pdHRlZCBmb3Igbm93LlxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxuICB9XHJcblxyXG4gIF9jb2VyY2VWYXJpYW50KHZhbCwgZHQpIHtcclxuICAgIC8vIElmIHZhbCBpcyBhbHJlYWR5IGEgVmFyaWFudCwgcGFzcyB0aHJvdWdoXHJcbiAgICBpZiAodmFsICYmIHZhbC5kYXRhVHlwZSAhPT0gdW5kZWZpbmVkICYmIHZhbC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXAgPSB7XHJcbiAgICAgIEJvb2xlYW46IERhdGFUeXBlLkJvb2xlYW4sXHJcbiAgICAgIEludDE2OiBEYXRhVHlwZS5JbnQxNixcclxuICAgICAgSW50MzI6IERhdGFUeXBlLkludDMyLFxyXG4gICAgICBJbnQ2NDogRGF0YVR5cGUuSW50NjQsXHJcbiAgICAgIFVJbnQxNjogRGF0YVR5cGUuVUludDE2LFxyXG4gICAgICBVSW50MzI6IERhdGFUeXBlLlVJbnQzMixcclxuICAgICAgVUludDY0OiBEYXRhVHlwZS5VSW50NjQsXHJcbiAgICAgIEZsb2F0OiBEYXRhVHlwZS5GbG9hdCxcclxuICAgICAgRG91YmxlOiBEYXRhVHlwZS5Eb3VibGUsXHJcbiAgICAgIFN0cmluZzogRGF0YVR5cGUuU3RyaW5nLFxyXG4gICAgICBEYXRlVGltZTogRGF0YVR5cGUuRGF0ZVRpbWUsXHJcbiAgICAgIEJ5dGVTdHJpbmc6IERhdGFUeXBlLkJ5dGVTdHJpbmcsXHJcbiAgICB9O1xyXG4gICAgbGV0IGRhdGFUeXBlID0gZHQgJiYgbWFwW2R0XSAhPT0gdW5kZWZpbmVkID8gbWFwW2R0XSA6IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvLyBJbmZlciB3aGVuIG5vdCBwcm92aWRlZFxyXG4gICAgaWYgKGRhdGFUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIC8vIEluZmVyIGZyb20gZmlyc3QgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdmFsWzBdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdudW1iZXInKSBkYXRhVHlwZSA9IE51bWJlci5pc0ludGVnZXIoZmlyc3QpID8gRGF0YVR5cGUuSW50MzIgOiBEYXRhVHlwZS5Eb3VibGU7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSAnYm9vbGVhbicpIGRhdGFUeXBlID0gRGF0YVR5cGUuQm9vbGVhbjtcclxuICAgICAgICBlbHNlIGRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCBhcnJheVR5cGU6IFZhcmlhbnRBcnJheVR5cGUuQXJyYXksIHZhbHVlOiB2YWwgfSk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgIGRhdGFUeXBlID0gTnVtYmVyLmlzSW50ZWdlcih2YWwpID8gRGF0YVR5cGUuSW50MzIgOiBEYXRhVHlwZS5Eb3VibGU7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgZGF0YVR5cGUgPSBEYXRhVHlwZS5Cb29sZWFuOyBicmVhaztcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgZGF0YVR5cGUgPSBEYXRhVHlwZS5TdHJpbmc7IGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBTdHJpbmdcclxuICAgICAgICAgIGRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCB2YWx1ZTogdmFsIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc3BlY3QgZXhwbGljaXQgZGF0YVR5cGUsIHN1cHBvcnQgYXJyYXlzIHdpdGggZWxlbWVudCBjb2VyY2lvblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICBjb25zdCBjb2VyY2VkQXJyID0gdmFsLm1hcCh2ID0+IHRoaXMuX2NvZXJjZUpzKHYsIGRhdGFUeXBlKSk7XHJcbiAgICAgIC8vIEZvciBudW1lcmljIGFycmF5IHR5cGVzLCB1c2UgVHlwZWRBcnJheXMgdG8gc2F0aXNmeSBub2RlLW9wY3VhIGVuY29kZXJzXHJcbiAgICAgIGNvbnN0IHRvVHlwZWQgPSAoYXJyLCBkdCkgPT4ge1xyXG4gICAgICAgIHN3aXRjaCAoZHQpIHtcclxuICAgICAgICAgIGNhc2UgRGF0YVR5cGUuSW50MTY6IHJldHVybiBJbnQxNkFycmF5LmZyb20oYXJyKTtcclxuICAgICAgICAgIGNhc2UgRGF0YVR5cGUuSW50MzI6IHJldHVybiBJbnQzMkFycmF5LmZyb20oYXJyKTtcclxuICAgICAgICAgIGNhc2UgRGF0YVR5cGUuSW50NjQ6IHJldHVybiBCaWdJbnQ2NEFycmF5LmZyb20oYXJyLm1hcCh4ID0+IEJpZ0ludChNYXRoLnRydW5jKHgpKSkpO1xyXG4gICAgICAgICAgY2FzZSBEYXRhVHlwZS5VSW50MTY6IHJldHVybiBVaW50MTZBcnJheS5mcm9tKGFycik7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLlVJbnQzMjogcmV0dXJuIFVpbnQzMkFycmF5LmZyb20oYXJyKTtcclxuICAgICAgICAgIGNhc2UgRGF0YVR5cGUuVUludDY0OiByZXR1cm4gQmlnVWludDY0QXJyYXkuZnJvbShhcnIubWFwKHggPT4gQmlnSW50KE1hdGgudHJ1bmMoeCkpKSk7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLkZsb2F0OiByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20oYXJyKTtcclxuICAgICAgICAgIGNhc2UgRGF0YVR5cGUuRG91YmxlOiByZXR1cm4gRmxvYXQ2NEFycmF5LmZyb20oYXJyKTtcclxuICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBhcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCB0eXBlZCA9IHRvVHlwZWQoY29lcmNlZEFyciwgZGF0YVR5cGUpO1xyXG4gICAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgYXJyYXlUeXBlOiBWYXJpYW50QXJyYXlUeXBlLkFycmF5LCB2YWx1ZTogdHlwZWQgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2VyY2VkID0gdGhpcy5fY29lcmNlSnModmFsLCBkYXRhVHlwZSk7XHJcbiAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgdmFsdWU6IGNvZXJjZWQgfSk7XHJcbiAgfVxyXG5cclxuICBfY29lcmNlSnModmFsLCBkYXRhVHlwZSkge1xyXG4gICAgLy8gSWYgZGF0YVR5cGUgaXMgYSBudW1lcmljIGJ1aWx0LWluIGlkICgwLi5uKSwgbWFwIGl0IHRvIGVudW0gY29uc3RhbnRcclxuICAgIGlmICh0eXBlb2YgZGF0YVR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIC8vIGRhdGFUeXBlIGFscmVhZHkgbnVtZXJpYzsgZmFsbC10aHJvdWdoXHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuQm9vbGVhbjpcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiB2YWwudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbCk7XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuSW50MTY6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuSW50MzI6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuSW50NjQ6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuVUludDE2OlxyXG4gICAgICBjYXNlIERhdGFUeXBlLlVJbnQzMjpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5VSW50NjQ6XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gTWF0aC50cnVuYyhuKSA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmModmFsKTtcclxuICAgICAgY2FzZSBEYXRhVHlwZS5GbG9hdDpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5Eb3VibGU6XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gbiA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWwpO1xyXG4gICAgICBjYXNlIERhdGFUeXBlLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT1BDVUFIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNO0VBQUVBLFdBQVc7RUFBRUMsWUFBWTtFQUFFQyxtQkFBbUI7RUFBRUMsY0FBYztFQUFFQyxPQUFPO0VBQUVDLGdCQUFnQjtFQUFFQztBQUFTLENBQUMsR0FBR0MsT0FBTyxDQUFDLFlBQVksQ0FBQztBQUVySSxNQUFNQyxZQUFZLENBQUM7RUFDakJDLFdBQVdBLENBQUNDLFlB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