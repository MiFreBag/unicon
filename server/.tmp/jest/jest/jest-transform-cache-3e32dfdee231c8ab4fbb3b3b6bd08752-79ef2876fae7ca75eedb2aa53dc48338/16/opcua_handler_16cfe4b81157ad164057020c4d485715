64fbe7632ab02bace6964f7403c23f5a
// server/handlers/opcua_handler.js
const {
  OPCUAClient,
  AttributeIds,
  MessageSecurityMode,
  SecurityPolicy,
  Variant,
  VariantArrayType,
  DataType
} = require('node-opcua');
class OPCUAHandler {
  constructor(connectionId, config = {}) {
    this.connectionId = connectionId;
    this.config = config;
    this.client = null;
    this.session = null;
    this.isConnected = false;
    // Cache of node metadata: { dataType, valueRank, arrayDimensions }
    this._metaCache = new Map();
  }
  async connect() {
    const endpointUrl = this.config.endpointUrl;
    if (!endpointUrl) throw new Error('OPC UA endpointUrl is required');
    const client = OPCUAClient.create({
      applicationName: 'Universal Test Client',
      securityMode: MessageSecurityMode.None,
      securityPolicy: SecurityPolicy.None,
      endpointMustExist: false,
      connectionStrategy: {
        initialDelay: 250,
        maxRetry: 1
      }
    });
    const timeoutMs = Number(this.config.timeoutMs || 5000);
    const connectPromise = client.connect(endpointUrl);
    const timed = new Promise((_, reject) => setTimeout(() => reject(new Error('OPC UA connect timeout')), timeoutMs));
    await Promise.race([connectPromise, timed]);
    const session = await client.createSession();
    this.client = client;
    this.session = session;
    this.isConnected = true;
    return {
      success: true
    };
  }
  async disconnect() {
    try {
      if (this.session) await this.session.close();
    } catch {}
    try {
      if (this.client) await this.client.disconnect();
    } catch {}
    this.client = null;
    this.session = null;
    this.isConnected = false;
    this._metaCache.clear();
    return {
      success: true
    };
  }
  async browse(nodeId = 'RootFolder') {
    if (!this.session) throw new Error('Not connected');
    const result = await this.session.browse(nodeId);
    return {
      success: true,
      data: result.references || []
    };
  }
  async read(nodes) {
    if (!this.session) throw new Error('Not connected');
    const nodesToRead = (Array.isArray(nodes) ? nodes : [nodes]).map(n => ({
      nodeId: n,
      attributeId: AttributeIds.Value
    }));
    const dataValues = await this.session.read(nodesToRead);
    return {
      success: true,
      data: dataValues
    };
  }
  async write(nodeId, value, dataType = null) {
    if (!this.session) throw new Error('Not connected');
    if (!nodeId) throw new Error('nodeId is required');

    // Fetch and cache node meta (datatype, valueRank, arrayDimensions)
    const meta = await this._getNodeMeta(nodeId);

    // Choose dataType: explicit > meta-inferred > heuristic
    let dt = dataType ?? meta?.dataType;

    // Validate rank/shape before coercion/write
    const rankCheck = this._validateRankAndShape(value, meta);
    if (!rankCheck.ok) {
      return {
        success: false,
        error: rankCheck.error
      };
    }
    const variant = this._coerceVariant(value, dt);
    const statusCode = await this.session.writeSingleNode(nodeId, variant);
    const scStr = statusCode?.name || String(statusCode || '');
    const ok = !!statusCode && (statusCode.value === 0 || scStr.includes('Good'));
    return {
      success: ok,
      statusCode: scStr
    };
  }
  async _inferDataTypeForNode(nodeId) {
    const dv = await this.session.read({
      nodeId,
      attributeId: AttributeIds.DataType
    });
    const dtNodeId = dv?.value?.value;
    if (dtNodeId && dtNodeId.namespace === 0 && typeof dtNodeId.value === 'number') {
      return dtNodeId.value;
    }
    // Fallback: read current value's variant to infer dataType
    const valDV = await this.session.read({
      nodeId,
      attributeId: AttributeIds.Value
    });
    const vt = valDV?.value?.dataType;
    if (typeof vt === 'number') return vt;
    return undefined;
  }
  async _getNodeMeta(nodeId) {
    if (this._metaCache.has(nodeId)) return this._metaCache.get(nodeId);
    const toRead = [{
      nodeId,
      attributeId: AttributeIds.DataType
    }, {
      nodeId,
      attributeId: AttributeIds.ValueRank
    }, {
      nodeId,
      attributeId: AttributeIds.ArrayDimensions
    }];
    const [dtDV, rankDV, dimsDV] = await this.session.read(toRead);
    const meta = {
      dataType: dtDV?.value?.value && dtDV.value.value.namespace === 0 ? dtDV.value.value.value : undefined,
      valueRank: typeof rankDV?.value?.value === 'number' ? rankDV.value.value : -1,
      arrayDimensions: Array.isArray(dimsDV?.value?.value) ? dimsDV.value.value : []
    };
    this._metaCache.set(nodeId, meta);
    return meta;
  }
  _validateRankAndShape(value, meta) {
    if (!meta) return {
      ok: true
    };
    const rank = meta.valueRank;
    if (rank == null || rank === -1) {
      // Scalar expected
      if (Array.isArray(value)) return {
        ok: false,
        error: 'BadTypeMismatch: scalar expected'
      };
      return {
        ok: true
      };
    }
    // Array expected (rank >= 1)
    if (!Array.isArray(value)) return {
      ok: false,
      error: 'BadTypeMismatch: array expected'
    };
    // Validate dimension lengths if provided (zeros mean unspecified)
    if (Array.isArray(meta.arrayDimensions) && meta.arrayDimensions.length > 0) {
      const fixedDims = meta.arrayDimensions.every(d => typeof d === 'number' && d > 0);
      if (fixedDims && meta.arrayDimensions.length === 1) {
        if (value.length !== meta.arrayDimensions[0]) {
          return {
            ok: false,
            error: `BadTypeMismatch: expected length ${meta.arrayDimensions[0]}`
          };
        }
      }
      // For multi-dim arrays, validation would need nested shapes; omitted for now.
    }
    return {
      ok: true
    };
  }
  _coerceVariant(val, dt) {
    // If val is already a Variant, pass through
    if (val && val.dataType !== undefined && val.value !== undefined) {
      return val;
    }
    const map = {
      Boolean: DataType.Boolean,
      Int16: DataType.Int16,
      Int32: DataType.Int32,
      Int64: DataType.Int64,
      UInt16: DataType.UInt16,
      UInt32: DataType.UInt32,
      UInt64: DataType.UInt64,
      Float: DataType.Float,
      Double: DataType.Double,
      String: DataType.String,
      DateTime: DataType.DateTime,
      ByteString: DataType.ByteString
    };
    let dataType = undefined;
    if (dt !== undefined && dt !== null) {
      if (typeof dt === 'number') dataType = dt; // already a DataType id
      else if (typeof dt === 'string' && map[dt] !== undefined) dataType = map[dt];
    }

    // Infer when not provided
    if (dataType === undefined) {
      if (Array.isArray(val)) {
        // Infer from first element
        const first = val[0];
        if (typeof first === 'number') dataType = Number.isInteger(first) ? DataType.Int32 : DataType.Double;else if (typeof first === 'boolean') dataType = DataType.Boolean;else dataType = DataType.String;
        return new Variant({
          dataType,
          arrayType: VariantArrayType.Array,
          value: val
        });
      }
      // If string but numeric-like, coerce to number to match common scalar writes
      if (typeof val === 'string') {
        const maybe = Number(val);
        if (Number.isFinite(maybe)) {
          dataType = Number.isInteger(maybe) ? DataType.Int32 : DataType.Double;
          return new Variant({
            dataType,
            value: maybe
          });
        }
      }
      switch (typeof val) {
        case 'number':
          dataType = Number.isInteger(val) ? DataType.Int32 : DataType.Double;
          break;
        case 'boolean':
          dataType = DataType.Boolean;
          break;
        case 'string':
          dataType = DataType.String;
          break;
        default:
          // Fallback to String
          dataType = DataType.String;
      }
      return new Variant({
        dataType,
        value: val
      });
    }

    // Respect explicit dataType, support arrays with element coercion
    if (Array.isArray(val)) {
      const coercedArr = val.map(v => this._coerceJs(v, dataType));
      // For numeric array types, use TypedArrays to satisfy node-opcua encoders
      const toTyped = (arr, dt) => {
        switch (dt) {
          case DataType.Int16:
            return Int16Array.from(arr);
          case DataType.Int32:
            return Int32Array.from(arr);
          case DataType.Int64:
            return BigInt64Array.from(arr.map(x => BigInt(Math.trunc(x))));
          case DataType.UInt16:
            return Uint16Array.from(arr);
          case DataType.UInt32:
            return Uint32Array.from(arr);
          case DataType.UInt64:
            return BigUint64Array.from(arr.map(x => BigInt(Math.trunc(x))));
          case DataType.Float:
            return Float32Array.from(arr);
          case DataType.Double:
            return Float64Array.from(arr);
          default:
            return arr;
        }
      };
      const typed = toTyped(coercedArr, dataType);
      return new Variant({
        dataType,
        arrayType: VariantArrayType.Array,
        value: typed
      });
    }
    const coerced = this._coerceJs(val, dataType);
    return new Variant({
      dataType,
      value: coerced
    });
  }
  _coerceJs(val, dataType) {
    // If dataType is a numeric built-in id (0..n), map it to enum constant
    if (typeof dataType === 'number') {
      // dataType already numeric; fall-through
    }
    switch (dataType) {
      case DataType.Boolean:
        if (typeof val === 'string') return val.toLowerCase() === 'true';
        return Boolean(val);
      case DataType.Int16:
      case DataType.Int32:
      case DataType.Int64:
      case DataType.UInt16:
      case DataType.UInt32:
      case DataType.UInt64:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? Math.trunc(n) : val;
        }
        return Math.trunc(val);
      case DataType.Float:
      case DataType.Double:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? n : val;
        }
        return Number(val);
      case DataType.String:
        return String(val);
      default:
        return val;
    }
  }
}
module.exports = OPCUAHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPUENVQUNsaWVudCIsIkF0dHJpYnV0ZUlkcyIsIk1lc3NhZ2VTZWN1cml0eU1vZGUiLCJTZWN1cml0eVBvbGljeSIsIlZhcmlhbnQiLCJWYXJpYW50QXJyYXlUeXBlIiwiRGF0YVR5cGUiLCJyZXF1aXJlIiwiT1BDVUFIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uSWQiLCJjb25maWciLCJjbGllbnQiLCJzZXNzaW9uIiwiaXNDb25uZWN0ZWQiLCJfbWV0YUNhY2hlIiwiTWFwIiwiY29ubmVjdCIsImVuZHBvaW50VXJsIiwiRXJyb3IiLCJjcmVhdGUiLCJhcHBsaWNhdGlvbk5hbWUiLCJzZWN1cml0eU1vZGUiLCJOb25lIiwic2VjdXJpdHlQb2xpY3kiLCJlbmRwb2ludE11c3RFeGlzdCIsImNvbm5lY3Rpb25TdHJhdGVneSIsImluaXRpYWxEZWxheSIsIm1heFJldHJ5IiwidGltZW91dE1zIiwiTnVtYmVyIiwiY29ubmVjdFByb21pc2UiLCJ0aW1lZCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsInJhY2UiLCJjcmVhdGVTZXNzaW9uIiwic3VjY2VzcyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImNsZWFyIiwiYnJvd3NlIiwibm9kZUlkIiwicmVzdWx0IiwiZGF0YSIsInJlZmVyZW5jZXMiLCJyZWFkIiwibm9kZXMiLCJub2Rlc1RvUmVhZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm4iLCJhdHRyaWJ1dGVJZCIsIlZhbHVlIiwiZGF0YVZhbHVlcyIsIndyaXRlIiwidmFsdWUiLCJkYXRhVHlwZSIsIm1ldGEiLCJfZ2V0Tm9kZU1ldGEiLCJkdCIsInJhbmtDaGVjayIsIl92YWxpZGF0ZVJhbmtBbmRTaGFwZSIsIm9rIiwiZXJyb3IiLCJ2YXJpYW50IiwiX2NvZXJjZVZhcmlhbnQiLCJzdGF0dXNDb2RlIiwid3JpdGVTaW5nbGVOb2RlIiwic2NTdHIiLCJuYW1lIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJfaW5mZXJEYXRhVHlwZUZvck5vZGUiLCJkdiIsImR0Tm9kZUlkIiwibmFtZXNwYWNlIiwidmFsRFYiLCJ2dCIsInVuZGVmaW5lZCIsImhhcyIsImdldCIsInRvUmVhZCIsIlZhbHVlUmFuayIsIkFycmF5RGltZW5zaW9ucyIsImR0RFYiLCJyYW5rRFYiLCJkaW1zRFYiLCJ2YWx1ZVJhbmsiLCJhcnJheURpbWVuc2lvbnMiLCJzZXQiLCJyYW5rIiwibGVuZ3RoIiwiZml4ZWREaW1zIiwiZXZlcnkiLCJkIiwidmFsIiwiQm9vbGVhbiIsIkludDE2IiwiSW50MzIiLCJJbnQ2NCIsIlVJbnQxNiIsIlVJbnQzMiIsIlVJbnQ2NCIsIkZsb2F0IiwiRG91YmxlIiwiRGF0ZVRpbWUiLCJCeXRlU3RyaW5nIiwiZmlyc3QiLCJpc0ludGVnZXIiLCJhcnJheVR5cGUiLCJtYXliZSIsImlzRmluaXRlIiwiY29lcmNlZEFyciIsInYiLCJfY29lcmNlSnMiLCJ0b1R5cGVkIiwiYXJyIiwiSW50MTZBcnJheSIsImZyb20iLCJJbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsIngiLCJCaWdJbnQiLCJNYXRoIiwidHJ1bmMiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnVWludDY0QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJ0eXBlZCIsImNvZXJjZWQiLCJ0b0xvd2VyQ2FzZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJvcGN1YV9oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlcnZlci9oYW5kbGVycy9vcGN1YV9oYW5kbGVyLmpzXHJcbmNvbnN0IHsgT1BDVUFDbGllbnQsIEF0dHJpYnV0ZUlkcywgTWVzc2FnZVNlY3VyaXR5TW9kZSwgU2VjdXJpdHlQb2xpY3ksIFZhcmlhbnQsIFZhcmlhbnRBcnJheVR5cGUsIERhdGFUeXBlIH0gPSByZXF1aXJlKCdub2RlLW9wY3VhJyk7XHJcblxyXG5jbGFzcyBPUENVQUhhbmRsZXIge1xyXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25JZCwgY29uZmlnID0ge30pIHtcclxuICAgIHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xyXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB0aGlzLmNsaWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xyXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgLy8gQ2FjaGUgb2Ygbm9kZSBtZXRhZGF0YTogeyBkYXRhVHlwZSwgdmFsdWVSYW5rLCBhcnJheURpbWVuc2lvbnMgfVxyXG4gICAgdGhpcy5fbWV0YUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY29ubmVjdCgpIHtcclxuICAgIGNvbnN0IGVuZHBvaW50VXJsID0gdGhpcy5jb25maWcuZW5kcG9pbnRVcmw7XHJcbiAgICBpZiAoIWVuZHBvaW50VXJsKSB0aHJvdyBuZXcgRXJyb3IoJ09QQyBVQSBlbmRwb2ludFVybCBpcyByZXF1aXJlZCcpO1xyXG5cclxuICAgIGNvbnN0IGNsaWVudCA9IE9QQ1VBQ2xpZW50LmNyZWF0ZSh7XHJcbiAgICAgIGFwcGxpY2F0aW9uTmFtZTogJ1VuaXZlcnNhbCBUZXN0IENsaWVudCcsXHJcbiAgICAgIHNlY3VyaXR5TW9kZTogTWVzc2FnZVNlY3VyaXR5TW9kZS5Ob25lLFxyXG4gICAgICBzZWN1cml0eVBvbGljeTogU2VjdXJpdHlQb2xpY3kuTm9uZSxcclxuICAgICAgZW5kcG9pbnRNdXN0RXhpc3Q6IGZhbHNlLFxyXG4gICAgICBjb25uZWN0aW9uU3RyYXRlZ3k6IHsgaW5pdGlhbERlbGF5OiAyNTAsIG1heFJldHJ5OiAxIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRpbWVvdXRNcyA9IE51bWJlcih0aGlzLmNvbmZpZy50aW1lb3V0TXMgfHwgNTAwMCk7XHJcbiAgICBjb25zdCBjb25uZWN0UHJvbWlzZSA9IGNsaWVudC5jb25uZWN0KGVuZHBvaW50VXJsKTtcclxuICAgIGNvbnN0IHRpbWVkID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWplY3QobmV3IEVycm9yKCdPUEMgVUEgY29ubmVjdCB0aW1lb3V0JykpLCB0aW1lb3V0TXMpKTtcclxuICAgIGF3YWl0IFByb21pc2UucmFjZShbY29ubmVjdFByb21pc2UsIHRpbWVkXSk7XHJcblxyXG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGNsaWVudC5jcmVhdGVTZXNzaW9uKCk7XHJcblxyXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XHJcbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcclxuICAgIHRyeSB7IGlmICh0aGlzLnNlc3Npb24pIGF3YWl0IHRoaXMuc2Vzc2lvbi5jbG9zZSgpOyB9IGNhdGNoIHt9XHJcbiAgICB0cnkgeyBpZiAodGhpcy5jbGllbnQpIGF3YWl0IHRoaXMuY2xpZW50LmRpc2Nvbm5lY3QoKTsgfSBjYXRjaCB7fVxyXG4gICAgdGhpcy5jbGllbnQgPSBudWxsO1xyXG4gICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcclxuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX21ldGFDYWNoZS5jbGVhcigpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgYnJvd3NlKG5vZGVJZCA9ICdSb290Rm9sZGVyJykge1xyXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZXNzaW9uLmJyb3dzZShub2RlSWQpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnJlZmVyZW5jZXMgfHwgW10gfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJlYWQobm9kZXMpIHtcclxuICAgIGlmICghdGhpcy5zZXNzaW9uKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcclxuICAgIGNvbnN0IG5vZGVzVG9SZWFkID0gKEFycmF5LmlzQXJyYXkobm9kZXMpID8gbm9kZXMgOiBbbm9kZXNdKS5tYXAoKG4pID0+ICh7IG5vZGVJZDogbiwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5WYWx1ZSB9KSk7XHJcbiAgICBjb25zdCBkYXRhVmFsdWVzID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQobm9kZXNUb1JlYWQpO1xyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogZGF0YVZhbHVlcyB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgd3JpdGUobm9kZUlkLCB2YWx1ZSwgZGF0YVR5cGUgPSBudWxsKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XHJcbiAgICBpZiAoIW5vZGVJZCkgdGhyb3cgbmV3IEVycm9yKCdub2RlSWQgaXMgcmVxdWlyZWQnKTtcclxuXHJcbiAgICAvLyBGZXRjaCBhbmQgY2FjaGUgbm9kZSBtZXRhIChkYXRhdHlwZSwgdmFsdWVSYW5rLCBhcnJheURpbWVuc2lvbnMpXHJcbiAgICBjb25zdCBtZXRhID0gYXdhaXQgdGhpcy5fZ2V0Tm9kZU1ldGEobm9kZUlkKTtcclxuXHJcbiAgICAvLyBDaG9vc2UgZGF0YVR5cGU6IGV4cGxpY2l0ID4gbWV0YS1pbmZlcnJlZCA+IGhldXJpc3RpY1xyXG4gICAgbGV0IGR0ID0gZGF0YVR5cGUgPz8gbWV0YT8uZGF0YVR5cGU7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgcmFuay9zaGFwZSBiZWZvcmUgY29lcmNpb24vd3JpdGVcclxuICAgIGNvbnN0IHJhbmtDaGVjayA9IHRoaXMuX3ZhbGlkYXRlUmFua0FuZFNoYXBlKHZhbHVlLCBtZXRhKTtcclxuICAgIGlmICghcmFua0NoZWNrLm9rKSB7XHJcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmFua0NoZWNrLmVycm9yIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgdmFyaWFudCA9IHRoaXMuX2NvZXJjZVZhcmlhbnQodmFsdWUsIGR0KTtcclxuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBhd2FpdCB0aGlzLnNlc3Npb24ud3JpdGVTaW5nbGVOb2RlKG5vZGVJZCwgdmFyaWFudCk7XHJcbiAgICBjb25zdCBzY1N0ciA9IHN0YXR1c0NvZGU/Lm5hbWUgfHwgU3RyaW5nKHN0YXR1c0NvZGUgfHwgJycpO1xyXG4gICAgY29uc3Qgb2sgPSAhIXN0YXR1c0NvZGUgJiYgKHN0YXR1c0NvZGUudmFsdWUgPT09IDAgfHwgc2NTdHIuaW5jbHVkZXMoJ0dvb2QnKSk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBvaywgc3RhdHVzQ29kZTogc2NTdHIgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIF9pbmZlckRhdGFUeXBlRm9yTm9kZShub2RlSWQpIHtcclxuICAgIGNvbnN0IGR2ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQoeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuRGF0YVR5cGUgfSk7XHJcbiAgICBjb25zdCBkdE5vZGVJZCA9IGR2Py52YWx1ZT8udmFsdWU7XHJcbiAgICBpZiAoZHROb2RlSWQgJiYgZHROb2RlSWQubmFtZXNwYWNlID09PSAwICYmIHR5cGVvZiBkdE5vZGVJZC52YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgcmV0dXJuIGR0Tm9kZUlkLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gRmFsbGJhY2s6IHJlYWQgY3VycmVudCB2YWx1ZSdzIHZhcmlhbnQgdG8gaW5mZXIgZGF0YVR5cGVcclxuICAgIGNvbnN0IHZhbERWID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQoeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuVmFsdWUgfSk7XHJcbiAgICBjb25zdCB2dCA9IHZhbERWPy52YWx1ZT8uZGF0YVR5cGU7XHJcbiAgICBpZiAodHlwZW9mIHZ0ID09PSAnbnVtYmVyJykgcmV0dXJuIHZ0O1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGFzeW5jIF9nZXROb2RlTWV0YShub2RlSWQpIHtcclxuICAgIGlmICh0aGlzLl9tZXRhQ2FjaGUuaGFzKG5vZGVJZCkpIHJldHVybiB0aGlzLl9tZXRhQ2FjaGUuZ2V0KG5vZGVJZCk7XHJcbiAgICBjb25zdCB0b1JlYWQgPSBbXHJcbiAgICAgIHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLkRhdGFUeXBlIH0sXHJcbiAgICAgIHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLlZhbHVlUmFuayB9LFxyXG4gICAgICB7IG5vZGVJZCwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5BcnJheURpbWVuc2lvbnMgfSxcclxuICAgIF07XHJcbiAgICBjb25zdCBbZHREViwgcmFua0RWLCBkaW1zRFZdID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQodG9SZWFkKTtcclxuICAgIGNvbnN0IG1ldGEgPSB7XHJcbiAgICAgIGRhdGFUeXBlOiAoZHREVj8udmFsdWU/LnZhbHVlICYmIGR0RFYudmFsdWUudmFsdWUubmFtZXNwYWNlID09PSAwKSA/IGR0RFYudmFsdWUudmFsdWUudmFsdWUgOiB1bmRlZmluZWQsXHJcbiAgICAgIHZhbHVlUmFuazogdHlwZW9mIHJhbmtEVj8udmFsdWU/LnZhbHVlID09PSAnbnVtYmVyJyA/IHJhbmtEVi52YWx1ZS52YWx1ZSA6IC0xLFxyXG4gICAgICBhcnJheURpbWVuc2lvbnM6IEFycmF5LmlzQXJyYXkoZGltc0RWPy52YWx1ZT8udmFsdWUpID8gZGltc0RWLnZhbHVlLnZhbHVlIDogW10sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fbWV0YUNhY2hlLnNldChub2RlSWQsIG1ldGEpO1xyXG4gICAgcmV0dXJuIG1ldGE7XHJcbiAgfVxyXG5cclxuICBfdmFsaWRhdGVSYW5rQW5kU2hhcGUodmFsdWUsIG1ldGEpIHtcclxuICAgIGlmICghbWV0YSkgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxuICAgIGNvbnN0IHJhbmsgPSBtZXRhLnZhbHVlUmFuaztcclxuICAgIGlmIChyYW5rID09IG51bGwgfHwgcmFuayA9PT0gLTEpIHtcclxuICAgICAgLy8gU2NhbGFyIGV4cGVjdGVkXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0JhZFR5cGVNaXNtYXRjaDogc2NhbGFyIGV4cGVjdGVkJyB9O1xyXG4gICAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG4gICAgfVxyXG4gICAgLy8gQXJyYXkgZXhwZWN0ZWQgKHJhbmsgPj0gMSlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdCYWRUeXBlTWlzbWF0Y2g6IGFycmF5IGV4cGVjdGVkJyB9O1xyXG4gICAgLy8gVmFsaWRhdGUgZGltZW5zaW9uIGxlbmd0aHMgaWYgcHJvdmlkZWQgKHplcm9zIG1lYW4gdW5zcGVjaWZpZWQpXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhLmFycmF5RGltZW5zaW9ucykgJiYgbWV0YS5hcnJheURpbWVuc2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXhlZERpbXMgPSBtZXRhLmFycmF5RGltZW5zaW9ucy5ldmVyeShkID0+IHR5cGVvZiBkID09PSAnbnVtYmVyJyAmJiBkID4gMCk7XHJcbiAgICAgIGlmIChmaXhlZERpbXMgJiYgbWV0YS5hcnJheURpbWVuc2lvbnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gbWV0YS5hcnJheURpbWVuc2lvbnNbMF0pIHtcclxuICAgICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGBCYWRUeXBlTWlzbWF0Y2g6IGV4cGVjdGVkIGxlbmd0aCAke21ldGEuYXJyYXlEaW1lbnNpb25zWzBdfWAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gRm9yIG11bHRpLWRpbSBhcnJheXMsIHZhbGlkYXRpb24gd291bGQgbmVlZCBuZXN0ZWQgc2hhcGVzOyBvbWl0dGVkIGZvciBub3cuXHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgX2NvZXJjZVZhcmlhbnQodmFsLCBkdCkge1xyXG4gICAgLy8gSWYgdmFsIGlzIGFscmVhZHkgYSBWYXJpYW50LCBwYXNzIHRocm91Z2hcclxuICAgIGlmICh2YWwgJiYgdmFsLmRhdGFUeXBlICE9PSB1bmRlZmluZWQgJiYgdmFsLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGNvbnN0IG1hcCA9IHtcclxuICAgICAgQm9vbGVhbjogRGF0YVR5cGUuQm9vbGVhbixcclxuICAgICAgSW50MTY6IERhdGFUeXBlLkludDE2LFxyXG4gICAgICBJbnQzMjogRGF0YVR5cGUuSW50MzIsXHJcbiAgICAgIEludDY0OiBEYXRhVHlwZS5JbnQ2NCxcclxuICAgICAgVUludDE2OiBEYXRhVHlwZS5VSW50MTYsXHJcbiAgICAgIFVJbnQzMjogRGF0YVR5cGUuVUludDMyLFxyXG4gICAgICBVSW50NjQ6IERhdGFUeXBlLlVJbnQ2NCxcclxuICAgICAgRmxvYXQ6IERhdGFUeXBlLkZsb2F0LFxyXG4gICAgICBEb3VibGU6IERhdGFUeXBlLkRvdWJsZSxcclxuICAgICAgU3RyaW5nOiBEYXRhVHlwZS5TdHJpbmcsXHJcbiAgICAgIERhdGVUaW1lOiBEYXRhVHlwZS5EYXRlVGltZSxcclxuICAgICAgQnl0ZVN0cmluZzogRGF0YVR5cGUuQnl0ZVN0cmluZyxcclxuICAgIH07XHJcbiAgICBsZXQgZGF0YVR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZHQgIT09IHVuZGVmaW5lZCAmJiBkdCAhPT0gbnVsbCkge1xyXG4gICAgICBpZiAodHlwZW9mIGR0ID09PSAnbnVtYmVyJykgZGF0YVR5cGUgPSBkdDsgLy8gYWxyZWFkeSBhIERhdGFUeXBlIGlkXHJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkdCA9PT0gJ3N0cmluZycgJiYgbWFwW2R0XSAhPT0gdW5kZWZpbmVkKSBkYXRhVHlwZSA9IG1hcFtkdF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5mZXIgd2hlbiBub3QgcHJvdmlkZWRcclxuICAgIGlmIChkYXRhVHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAvLyBJbmZlciBmcm9tIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHZhbFswXTtcclxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSAnbnVtYmVyJykgZGF0YVR5cGUgPSBOdW1iZXIuaXNJbnRlZ2VyKGZpcnN0KSA/IERhdGFUeXBlLkludDMyIDogRGF0YVR5cGUuRG91YmxlO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ2Jvb2xlYW4nKSBkYXRhVHlwZSA9IERhdGFUeXBlLkJvb2xlYW47XHJcbiAgICAgICAgZWxzZSBkYXRhVHlwZSA9IERhdGFUeXBlLlN0cmluZztcclxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgYXJyYXlUeXBlOiBWYXJpYW50QXJyYXlUeXBlLkFycmF5LCB2YWx1ZTogdmFsIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHN0cmluZyBidXQgbnVtZXJpYy1saWtlLCBjb2VyY2UgdG8gbnVtYmVyIHRvIG1hdGNoIGNvbW1vbiBzY2FsYXIgd3JpdGVzXHJcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IG1heWJlID0gTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShtYXliZSkpIHtcclxuICAgICAgICAgIGRhdGFUeXBlID0gTnVtYmVyLmlzSW50ZWdlcihtYXliZSkgPyBEYXRhVHlwZS5JbnQzMiA6IERhdGFUeXBlLkRvdWJsZTtcclxuICAgICAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCB2YWx1ZTogbWF5YmUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICBkYXRhVHlwZSA9IE51bWJlci5pc0ludGVnZXIodmFsKSA/IERhdGFUeXBlLkludDMyIDogRGF0YVR5cGUuRG91YmxlOyBicmVhaztcclxuICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgIGRhdGFUeXBlID0gRGF0YVR5cGUuQm9vbGVhbjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgIGRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gU3RyaW5nXHJcbiAgICAgICAgICBkYXRhVHlwZSA9IERhdGFUeXBlLlN0cmluZztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgdmFsdWU6IHZhbCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNwZWN0IGV4cGxpY2l0IGRhdGFUeXBlLCBzdXBwb3J0IGFycmF5cyB3aXRoIGVsZW1lbnQgY29lcmNpb25cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgY29uc3QgY29lcmNlZEFyciA9IHZhbC5tYXAodiA9PiB0aGlzLl9jb2VyY2VKcyh2LCBkYXRhVHlwZSkpO1xyXG4gICAgICAvLyBGb3IgbnVtZXJpYyBhcnJheSB0eXBlcywgdXNlIFR5cGVkQXJyYXlzIHRvIHNhdGlzZnkgbm9kZS1vcGN1YSBlbmNvZGVyc1xyXG4gICAgICBjb25zdCB0b1R5cGVkID0gKGFyciwgZHQpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGR0KSB7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLkludDE2OiByZXR1cm4gSW50MTZBcnJheS5mcm9tKGFycik7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLkludDMyOiByZXR1cm4gSW50MzJBcnJheS5mcm9tKGFycik7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLkludDY0OiByZXR1cm4gQmlnSW50NjRBcnJheS5mcm9tKGFyci5tYXAoeCA9PiBCaWdJbnQoTWF0aC50cnVuYyh4KSkpKTtcclxuICAgICAgICAgIGNhc2UgRGF0YVR5cGUuVUludDE2OiByZXR1cm4gVWludDE2QXJyYXkuZnJvbShhcnIpO1xyXG4gICAgICAgICAgY2FzZSBEYXRhVHlwZS5VSW50MzI6IHJldHVybiBVaW50MzJBcnJheS5mcm9tKGFycik7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLlVJbnQ2NDogcmV0dXJuIEJpZ1VpbnQ2NEFycmF5LmZyb20oYXJyLm1hcCh4ID0+IEJpZ0ludChNYXRoLnRydW5jKHgpKSkpO1xyXG4gICAgICAgICAgY2FzZSBEYXRhVHlwZS5GbG9hdDogcmV0dXJuIEZsb2F0MzJBcnJheS5mcm9tKGFycik7XHJcbiAgICAgICAgICBjYXNlIERhdGFUeXBlLkRvdWJsZTogcmV0dXJuIEZsb2F0NjRBcnJheS5mcm9tKGFycik7XHJcbiAgICAgICAgICBkZWZhdWx0OiByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgICAgY29uc3QgdHlwZWQgPSB0b1R5cGVkKGNvZXJjZWRBcnIsIGRhdGFUeXBlKTtcclxuICAgICAgcmV0dXJuIG5ldyBWYXJpYW50KHsgZGF0YVR5cGUsIGFycmF5VHlwZTogVmFyaWFudEFycmF5VHlwZS5BcnJheSwgdmFsdWU6IHR5cGVkIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29lcmNlZCA9IHRoaXMuX2NvZXJjZUpzKHZhbCwgZGF0YVR5cGUpO1xyXG4gICAgcmV0dXJuIG5ldyBWYXJpYW50KHsgZGF0YVR5cGUsIHZhbHVlOiBjb2VyY2VkIH0pO1xyXG4gIH1cclxuXHJcbiAgX2NvZXJjZUpzKHZhbCwgZGF0YVR5cGUpIHtcclxuICAgIC8vIElmIGRhdGFUeXBlIGlzIGEgbnVtZXJpYyBidWlsdC1pbiBpZCAoMC4ubiksIG1hcCBpdCB0byBlbnVtIGNvbnN0YW50XHJcbiAgICBpZiAodHlwZW9mIGRhdGFUeXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAvLyBkYXRhVHlwZSBhbHJlYWR5IG51bWVyaWM7IGZhbGwtdGhyb3VnaFxyXG4gICAgfVxyXG4gICAgc3dpdGNoIChkYXRhVHlwZSkge1xyXG4gICAgICBjYXNlIERhdGFUeXBlLkJvb2xlYW46XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSByZXR1cm4gdmFsLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih2YWwpO1xyXG4gICAgICBjYXNlIERhdGFUeXBlLkludDE2OlxyXG4gICAgICBjYXNlIERhdGFUeXBlLkludDMyOlxyXG4gICAgICBjYXNlIERhdGFUeXBlLkludDY0OlxyXG4gICAgICBjYXNlIERhdGFUeXBlLlVJbnQxNjpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5VSW50MzI6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuVUludDY0OlxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgY29uc3QgbiA9IE51bWJlcih2YWwpO1xyXG4gICAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShuKSA/IE1hdGgudHJ1bmMobikgOiB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKHZhbCk7XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuRmxvYXQ6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuRG91YmxlOlxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgY29uc3QgbiA9IE51bWJlcih2YWwpO1xyXG4gICAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShuKSA/IG4gOiB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsKTtcclxuICAgICAgY2FzZSBEYXRhVHlwZS5TdHJpbmc6XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWwpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE9QQ1VBSGFuZGxlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTTtFQUFFQSxXQUFXO0VBQUVDLFlBQVk7RUFBRUMsbUJBQW1CO0VBQUVDLGNBQWM7RUFBRUMsT0FBTztFQUFFQyxnQkFBZ0I7RUFBRUM7QUFBUyxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxZQUFZLENBQUM7QUFFckksTUFBTUMsWUFBWSxDQUFDO0VBQ2pCQyxXQUFXQSxDQUFDQyxZQUFZLEVBQUVDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRTtJQUNyQyxJQUFJLENBQUNELFlBQVksR0FBR0EsWUFBWTtJQUNoQyxJQUFJLENBQUNDLE1BQU0sR0FBR0EsTUFBTTtJQUNwQixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJO0lBQ2xCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUk7SUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUcsS0FBSztJQUN4QjtJQUNBLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUlDLEdBQUcsQ0FBQyxDQUFDO0VBQzdCO0VBRUEsTUFBTUMsT0FBT0EsQ0FBQSxFQUFHO0lBQ2QsTUFBTUMsV0FBVyxHQUFHLElBQUksQ0FBQ1AsTUFBTSxDQUFDTyxXQUFXO0lBQzNDLElB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