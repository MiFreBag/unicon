a7284ea69f49815b52ca82a25ac8f207
// server/handlers/opcua_handler.js
const {
  OPCUAClient,
  AttributeIds,
  MessageSecurityMode,
  SecurityPolicy,
  Variant,
  VariantArrayType,
  DataType
} = require('node-opcua');
class OPCUAHandler {
  constructor(connectionId, config = {}) {
    this.connectionId = connectionId;
    this.config = config;
    this.client = null;
    this.session = null;
    this.isConnected = false;
    // Cache of node metadata: { dataType, valueRank, arrayDimensions }
    this._metaCache = new Map();
  }
  async connect() {
    const endpointUrl = this.config.endpointUrl;
    if (!endpointUrl) throw new Error('OPC UA endpointUrl is required');
    const client = OPCUAClient.create({
      applicationName: 'Universal Test Client',
      securityMode: MessageSecurityMode.None,
      securityPolicy: SecurityPolicy.None,
      endpointMustExist: false,
      connectionStrategy: {
        initialDelay: 250,
        maxRetry: 1
      }
    });
    const timeoutMs = Number(this.config.timeoutMs || 5000);
    const connectPromise = client.connect(endpointUrl);
    const timed = new Promise((_, reject) => setTimeout(() => reject(new Error('OPC UA connect timeout')), timeoutMs));
    await Promise.race([connectPromise, timed]);
    const session = await client.createSession();
    this.client = client;
    this.session = session;
    this.isConnected = true;
    return {
      success: true
    };
  }
  async disconnect() {
    try {
      if (this.session) await this.session.close();
    } catch {}
    try {
      if (this.client) await this.client.disconnect();
    } catch {}
    this.client = null;
    this.session = null;
    this.isConnected = false;
    this._metaCache.clear();
    return {
      success: true
    };
  }
  async browse(nodeId = 'RootFolder') {
    if (!this.session) throw new Error('Not connected');
    const result = await this.session.browse(nodeId);
    return {
      success: true,
      data: result.references || []
    };
  }
  async read(nodes) {
    if (!this.session) throw new Error('Not connected');
    const nodesToRead = (Array.isArray(nodes) ? nodes : [nodes]).map(n => ({
      nodeId: n,
      attributeId: AttributeIds.Value
    }));
    const dataValues = await this.session.read(nodesToRead);
    return {
      success: true,
      data: dataValues
    };
  }
  async write(nodeId, value, dataType = null) {
    if (!this.session) throw new Error('Not connected');
    if (!nodeId) throw new Error('nodeId is required');

    // Fetch and cache node meta (datatype, valueRank, arrayDimensions)
    const meta = await this._getNodeMeta(nodeId);

    // Choose dataType: explicit > meta-inferred > heuristic
    let dt = dataType ?? meta?.dataType;

    // Validate rank/shape before coercion/write
    const rankCheck = this._validateRankAndShape(value, meta);
    if (!rankCheck.ok) {
      return {
        success: false,
        error: rankCheck.error
      };
    }
    const variant = this._coerceVariant(value, dt);
    const statusCode = await this.session.writeSingleNode(nodeId, variant);
    const scStr = statusCode?.name || String(statusCode || '');
    const ok = !!statusCode && (statusCode.value === 0 || scStr.includes('Good'));
    return {
      success: ok,
      statusCode: scStr
    };
  }
  async _inferDataTypeForNode(nodeId) {
    const dv = await this.session.read({
      nodeId,
      attributeId: AttributeIds.DataType
    });
    const dtNodeId = dv?.value?.value;
    if (dtNodeId && dtNodeId.namespace === 0 && typeof dtNodeId.value === 'number') {
      return dtNodeId.value;
    }
    // Fallback: read current value's variant to infer dataType
    const valDV = await this.session.read({
      nodeId,
      attributeId: AttributeIds.Value
    });
    const vt = valDV?.value?.dataType;
    if (typeof vt === 'number') return vt;
    return undefined;
  }
  async _getNodeMeta(nodeId) {
    if (this._metaCache.has(nodeId)) return this._metaCache.get(nodeId);
    const toRead = [{
      nodeId,
      attributeId: AttributeIds.DataType
    }, {
      nodeId,
      attributeId: AttributeIds.ValueRank
    }, {
      nodeId,
      attributeId: AttributeIds.ArrayDimensions
    }];
    const [dtDV, rankDV, dimsDV] = await this.session.read(toRead);
    const meta = {
      dataType: dtDV?.value?.value && dtDV.value.value.namespace === 0 ? dtDV.value.value.value : undefined,
      valueRank: typeof rankDV?.value?.value === 'number' ? rankDV.value.value : -1,
      arrayDimensions: Array.isArray(dimsDV?.value?.value) ? dimsDV.value.value : []
    };
    this._metaCache.set(nodeId, meta);
    return meta;
  }
  _validateRankAndShape(value, meta) {
    if (!meta) return {
      ok: true
    };
    const rank = meta.valueRank;
    if (rank == null || rank === -1) {
      // Scalar expected
      if (Array.isArray(value)) return {
        ok: false,
        error: 'BadTypeMismatch: scalar expected'
      };
      return {
        ok: true
      };
    }
    // Array expected (rank >= 1)
    if (!Array.isArray(value)) return {
      ok: false,
      error: 'BadTypeMismatch: array expected'
    };
    // Validate dimension lengths if provided (zeros mean unspecified)
    if (Array.isArray(meta.arrayDimensions) && meta.arrayDimensions.length > 0) {
      const fixedDims = meta.arrayDimensions.every(d => typeof d === 'number' && d > 0);
      if (fixedDims && meta.arrayDimensions.length === 1) {
        if (value.length !== meta.arrayDimensions[0]) {
          return {
            ok: false,
            error: `BadTypeMismatch: expected length ${meta.arrayDimensions[0]}`
          };
        }
      }
      // For multi-dim arrays, validation would need nested shapes; omitted for now.
    }
    return {
      ok: true
    };
  }
  _coerceVariant(val, dt) {
    // If val is already a Variant, pass through
    if (val && val.dataType !== undefined && val.value !== undefined) {
      return val;
    }
    const map = {
      Boolean: DataType.Boolean,
      Int16: DataType.Int16,
      Int32: DataType.Int32,
      Int64: DataType.Int64,
      UInt16: DataType.UInt16,
      UInt32: DataType.UInt32,
      UInt64: DataType.UInt64,
      Float: DataType.Float,
      Double: DataType.Double,
      String: DataType.String,
      DateTime: DataType.DateTime,
      ByteString: DataType.ByteString
    };
    let dataType = undefined;
    if (dt !== undefined && dt !== null) {
      if (typeof dt === 'number') dataType = dt; // already a DataType id
      else if (typeof dt === 'string' && map[dt] !== undefined) dataType = map[dt];
    }

    // Infer when not provided
    if (dataType === undefined) {
      if (Array.isArray(val)) {
        // Infer from first element
        const first = val[0];
        if (typeof first === 'number') dataType = Number.isInteger(first) ? DataType.Int32 : DataType.Double;else if (typeof first === 'boolean') dataType = DataType.Boolean;else dataType = DataType.String;
        return new Variant({
          dataType,
          arrayType: VariantArrayType.Array,
          value: val
        });
      }
      // If string but numeric-like, coerce to number to match common scalar writes
      if (typeof val === 'string') {
        const maybe = Number(val);
        if (Number.isFinite(maybe)) {
          dataType = Number.isInteger(maybe) ? DataType.Int32 : DataType.Double;
          return new Variant({
            dataType,
            value: maybe
          });
        }
      }
      switch (typeof val) {
        case 'number':
          dataType = Number.isInteger(val) ? DataType.Int32 : DataType.Double;
          break;
        case 'boolean':
          dataType = DataType.Boolean;
          break;
        case 'string':
          dataType = DataType.String;
          break;
        default:
          // Fallback to String
          dataType = DataType.String;
      }
      return new Variant({
        dataType,
        value: val
      });
    }

    // Respect explicit dataType, support arrays with element coercion
    if (Array.isArray(val)) {
      const coercedArr = val.map(v => this._coerceJs(v, dataType));
      let arrVal = coercedArr;
      switch (dataType) {
        case DataType.Int16:
          arrVal = Int16Array.from(coercedArr);
          break;
        case DataType.Int32:
          arrVal = Int32Array.from(coercedArr);
          break;
        case DataType.UInt16:
          arrVal = Uint16Array.from(coercedArr);
          break;
        case DataType.UInt32:
          arrVal = Uint32Array.from(coercedArr);
          break;
        case DataType.Float:
          arrVal = Float32Array.from(coercedArr);
          break;
        case DataType.Double:
          arrVal = Float64Array.from(coercedArr);
          break;
        default:
          /* leave as plain array for 64-bit and others */break;
      }
      return new Variant({
        dataType,
        arrayType: VariantArrayType.Array,
        value: arrVal
      });
    }
    const coerced = this._coerceJs(val, dataType);
    return new Variant({
      dataType,
      value: coerced
    });
  }
  _coerceJs(val, dataType) {
    // If dataType is a numeric built-in id (0..n), map it to enum constant
    if (typeof dataType === 'number') {
      // dataType already numeric; fall-through
    }
    switch (dataType) {
      case DataType.Boolean:
        if (typeof val === 'string') return val.toLowerCase() === 'true';
        return Boolean(val);
      case DataType.Int16:
      case DataType.Int32:
      case DataType.Int64:
      case DataType.UInt16:
      case DataType.UInt32:
      case DataType.UInt64:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? Math.trunc(n) : val;
        }
        return Math.trunc(val);
      case DataType.Float:
      case DataType.Double:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? n : val;
        }
        return Number(val);
      case DataType.String:
        return String(val);
      default:
        return val;
    }
  }
}
module.exports = OPCUAHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPUENVQUNsaWVudCIsIkF0dHJpYnV0ZUlkcyIsIk1lc3NhZ2VTZWN1cml0eU1vZGUiLCJTZWN1cml0eVBvbGljeSIsIlZhcmlhbnQiLCJWYXJpYW50QXJyYXlUeXBlIiwiRGF0YVR5cGUiLCJyZXF1aXJlIiwiT1BDVUFIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uSWQiLCJjb25maWciLCJjbGllbnQiLCJzZXNzaW9uIiwiaXNDb25uZWN0ZWQiLCJfbWV0YUNhY2hlIiwiTWFwIiwiY29ubmVjdCIsImVuZHBvaW50VXJsIiwiRXJyb3IiLCJjcmVhdGUiLCJhcHBsaWNhdGlvbk5hbWUiLCJzZWN1cml0eU1vZGUiLCJOb25lIiwic2VjdXJpdHlQb2xpY3kiLCJlbmRwb2ludE11c3RFeGlzdCIsImNvbm5lY3Rpb25TdHJhdGVneSIsImluaXRpYWxEZWxheSIsIm1heFJldHJ5IiwidGltZW91dE1zIiwiTnVtYmVyIiwiY29ubmVjdFByb21pc2UiLCJ0aW1lZCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsInJhY2UiLCJjcmVhdGVTZXNzaW9uIiwic3VjY2VzcyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImNsZWFyIiwiYnJvd3NlIiwibm9kZUlkIiwicmVzdWx0IiwiZGF0YSIsInJlZmVyZW5jZXMiLCJyZWFkIiwibm9kZXMiLCJub2Rlc1RvUmVhZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm4iLCJhdHRyaWJ1dGVJZCIsIlZhbHVlIiwiZGF0YVZhbHVlcyIsIndyaXRlIiwidmFsdWUiLCJkYXRhVHlwZSIsIm1ldGEiLCJfZ2V0Tm9kZU1ldGEiLCJkdCIsInJhbmtDaGVjayIsIl92YWxpZGF0ZVJhbmtBbmRTaGFwZSIsIm9rIiwiZXJyb3IiLCJ2YXJpYW50IiwiX2NvZXJjZVZhcmlhbnQiLCJzdGF0dXNDb2RlIiwid3JpdGVTaW5nbGVOb2RlIiwic2NTdHIiLCJuYW1lIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJfaW5mZXJEYXRhVHlwZUZvck5vZGUiLCJkdiIsImR0Tm9kZUlkIiwibmFtZXNwYWNlIiwidmFsRFYiLCJ2dCIsInVuZGVmaW5lZCIsImhhcyIsImdldCIsInRvUmVhZCIsIlZhbHVlUmFuayIsIkFycmF5RGltZW5zaW9ucyIsImR0RFYiLCJyYW5rRFYiLCJkaW1zRFYiLCJ2YWx1ZVJhbmsiLCJhcnJheURpbWVuc2lvbnMiLCJzZXQiLCJyYW5rIiwibGVuZ3RoIiwiZml4ZWREaW1zIiwiZXZlcnkiLCJkIiwidmFsIiwiQm9vbGVhbiIsIkludDE2IiwiSW50MzIiLCJJbnQ2NCIsIlVJbnQxNiIsIlVJbnQzMiIsIlVJbnQ2NCIsIkZsb2F0IiwiRG91YmxlIiwiRGF0ZVRpbWUiLCJCeXRlU3RyaW5nIiwiZmlyc3QiLCJpc0ludGVnZXIiLCJhcnJheVR5cGUiLCJtYXliZSIsImlzRmluaXRlIiwiY29lcmNlZEFyciIsInYiLCJfY29lcmNlSnMiLCJhcnJWYWwiLCJJbnQxNkFycmF5IiwiZnJvbSIsIkludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiY29lcmNlZCIsInRvTG93ZXJDYXNlIiwiTWF0aCIsInRydW5jIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIm9wY3VhX2hhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2VydmVyL2hhbmRsZXJzL29wY3VhX2hhbmRsZXIuanNcclxuY29uc3QgeyBPUENVQUNsaWVudCwgQXR0cmlidXRlSWRzLCBNZXNzYWdlU2VjdXJpdHlNb2RlLCBTZWN1cml0eVBvbGljeSwgVmFyaWFudCwgVmFyaWFudEFycmF5VHlwZSwgRGF0YVR5cGUgfSA9IHJlcXVpcmUoJ25vZGUtb3BjdWEnKTtcclxuXHJcbmNsYXNzIE9QQ1VBSGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbklkLCBjb25maWcgPSB7fSkge1xyXG4gICAgdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAvLyBDYWNoZSBvZiBub2RlIG1ldGFkYXRhOiB7IGRhdGFUeXBlLCB2YWx1ZVJhbmssIGFycmF5RGltZW5zaW9ucyB9XHJcbiAgICB0aGlzLl9tZXRhQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjb25uZWN0KCkge1xyXG4gICAgY29uc3QgZW5kcG9pbnRVcmwgPSB0aGlzLmNvbmZpZy5lbmRwb2ludFVybDtcclxuICAgIGlmICghZW5kcG9pbnRVcmwpIHRocm93IG5ldyBFcnJvcignT1BDIFVBIGVuZHBvaW50VXJsIGlzIHJlcXVpcmVkJyk7XHJcblxyXG4gICAgY29uc3QgY2xpZW50ID0gT1BDVUFDbGllbnQuY3JlYXRlKHtcclxuICAgICAgYXBwbGljYXRpb25OYW1lOiAnVW5pdmVyc2FsIFRlc3QgQ2xpZW50JyxcclxuICAgICAgc2VjdXJpdHlNb2RlOiBNZXNzYWdlU2VjdXJpdHlNb2RlLk5vbmUsXHJcbiAgICAgIHNlY3VyaXR5UG9saWN5OiBTZWN1cml0eVBvbGljeS5Ob25lLFxyXG4gICAgICBlbmRwb2ludE11c3RFeGlzdDogZmFsc2UsXHJcbiAgICAgIGNvbm5lY3Rpb25TdHJhdGVneTogeyBpbml0aWFsRGVsYXk6IDI1MCwgbWF4UmV0cnk6IDEgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdGltZW91dE1zID0gTnVtYmVyKHRoaXMuY29uZmlnLnRpbWVvdXRNcyB8fCA1MDAwKTtcclxuICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlID0gY2xpZW50LmNvbm5lY3QoZW5kcG9pbnRVcmwpO1xyXG4gICAgY29uc3QgdGltZWQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ09QQyBVQSBjb25uZWN0IHRpbWVvdXQnKSksIHRpbWVvdXRNcykpO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtjb25uZWN0UHJvbWlzZSwgdGltZWRdKTtcclxuXHJcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgY2xpZW50LmNyZWF0ZVNlc3Npb24oKTtcclxuXHJcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBkaXNjb25uZWN0KCkge1xyXG4gICAgdHJ5IHsgaWYgKHRoaXMuc2Vzc2lvbikgYXdhaXQgdGhpcy5zZXNzaW9uLmNsb3NlKCk7IH0gY2F0Y2gge31cclxuICAgIHRyeSB7IGlmICh0aGlzLmNsaWVudCkgYXdhaXQgdGhpcy5jbGllbnQuZGlzY29ubmVjdCgpOyB9IGNhdGNoIHt9XHJcbiAgICB0aGlzLmNsaWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xyXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbWV0YUNhY2hlLmNsZWFyKCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBicm93c2Uobm9kZUlkID0gJ1Jvb3RGb2xkZXInKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlc3Npb24uYnJvd3NlKG5vZGVJZCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQucmVmZXJlbmNlcyB8fCBbXSB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVhZChub2Rlcykge1xyXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xyXG4gICAgY29uc3Qgbm9kZXNUb1JlYWQgPSAoQXJyYXkuaXNBcnJheShub2RlcykgPyBub2RlcyA6IFtub2Rlc10pLm1hcCgobikgPT4gKHsgbm9kZUlkOiBuLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLlZhbHVlIH0pKTtcclxuICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBhd2FpdCB0aGlzLnNlc3Npb24ucmVhZChub2Rlc1RvUmVhZCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBkYXRhVmFsdWVzIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyB3cml0ZShub2RlSWQsIHZhbHVlLCBkYXRhVHlwZSA9IG51bGwpIHtcclxuICAgIGlmICghdGhpcy5zZXNzaW9uKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcclxuICAgIGlmICghbm9kZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ25vZGVJZCBpcyByZXF1aXJlZCcpO1xyXG5cclxuICAgIC8vIEZldGNoIGFuZCBjYWNoZSBub2RlIG1ldGEgKGRhdGF0eXBlLCB2YWx1ZVJhbmssIGFycmF5RGltZW5zaW9ucylcclxuICAgIGNvbnN0IG1ldGEgPSBhd2FpdCB0aGlzLl9nZXROb2RlTWV0YShub2RlSWQpO1xyXG5cclxuICAgIC8vIENob29zZSBkYXRhVHlwZTogZXhwbGljaXQgPiBtZXRhLWluZmVycmVkID4gaGV1cmlzdGljXHJcbiAgICBsZXQgZHQgPSBkYXRhVHlwZSA/PyBtZXRhPy5kYXRhVHlwZTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSByYW5rL3NoYXBlIGJlZm9yZSBjb2VyY2lvbi93cml0ZVxyXG4gICAgY29uc3QgcmFua0NoZWNrID0gdGhpcy5fdmFsaWRhdGVSYW5rQW5kU2hhcGUodmFsdWUsIG1ldGEpO1xyXG4gICAgaWYgKCFyYW5rQ2hlY2sub2spIHtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByYW5rQ2hlY2suZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YXJpYW50ID0gdGhpcy5fY29lcmNlVmFyaWFudCh2YWx1ZSwgZHQpO1xyXG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi53cml0ZVNpbmdsZU5vZGUobm9kZUlkLCB2YXJpYW50KTtcclxuICAgIGNvbnN0IHNjU3RyID0gc3RhdHVzQ29kZT8ubmFtZSB8fCBTdHJpbmcoc3RhdHVzQ29kZSB8fCAnJyk7XHJcbiAgICBjb25zdCBvayA9ICEhc3RhdHVzQ29kZSAmJiAoc3RhdHVzQ29kZS52YWx1ZSA9PT0gMCB8fCBzY1N0ci5pbmNsdWRlcygnR29vZCcpKTtcclxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IG9rLCBzdGF0dXNDb2RlOiBzY1N0ciB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2luZmVyRGF0YVR5cGVGb3JOb2RlKG5vZGVJZCkge1xyXG4gICAgY29uc3QgZHYgPSBhd2FpdCB0aGlzLnNlc3Npb24ucmVhZCh7IG5vZGVJZCwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5EYXRhVHlwZSB9KTtcclxuICAgIGNvbnN0IGR0Tm9kZUlkID0gZHY/LnZhbHVlPy52YWx1ZTtcclxuICAgIGlmIChkdE5vZGVJZCAmJiBkdE5vZGVJZC5uYW1lc3BhY2UgPT09IDAgJiYgdHlwZW9mIGR0Tm9kZUlkLnZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICByZXR1cm4gZHROb2RlSWQudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjazogcmVhZCBjdXJyZW50IHZhbHVlJ3MgdmFyaWFudCB0byBpbmZlciBkYXRhVHlwZVxyXG4gICAgY29uc3QgdmFsRFYgPSBhd2FpdCB0aGlzLnNlc3Npb24ucmVhZCh7IG5vZGVJZCwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5WYWx1ZSB9KTtcclxuICAgIGNvbnN0IHZ0ID0gdmFsRFY/LnZhbHVlPy5kYXRhVHlwZTtcclxuICAgIGlmICh0eXBlb2YgdnQgPT09ICdudW1iZXInKSByZXR1cm4gdnQ7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgX2dldE5vZGVNZXRhKG5vZGVJZCkge1xyXG4gICAgaWYgKHRoaXMuX21ldGFDYWNoZS5oYXMobm9kZUlkKSkgcmV0dXJuIHRoaXMuX21ldGFDYWNoZS5nZXQobm9kZUlkKTtcclxuICAgIGNvbnN0IHRvUmVhZCA9IFtcclxuICAgICAgeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuRGF0YVR5cGUgfSxcclxuICAgICAgeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuVmFsdWVSYW5rIH0sXHJcbiAgICAgIHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLkFycmF5RGltZW5zaW9ucyB9LFxyXG4gICAgXTtcclxuICAgIGNvbnN0IFtkdERWLCByYW5rRFYsIGRpbXNEVl0gPSBhd2FpdCB0aGlzLnNlc3Npb24ucmVhZCh0b1JlYWQpO1xyXG4gICAgY29uc3QgbWV0YSA9IHtcclxuICAgICAgZGF0YVR5cGU6IChkdERWPy52YWx1ZT8udmFsdWUgJiYgZHREVi52YWx1ZS52YWx1ZS5uYW1lc3BhY2UgPT09IDApID8gZHREVi52YWx1ZS52YWx1ZS52YWx1ZSA6IHVuZGVmaW5lZCxcclxuICAgICAgdmFsdWVSYW5rOiB0eXBlb2YgcmFua0RWPy52YWx1ZT8udmFsdWUgPT09ICdudW1iZXInID8gcmFua0RWLnZhbHVlLnZhbHVlIDogLTEsXHJcbiAgICAgIGFycmF5RGltZW5zaW9uczogQXJyYXkuaXNBcnJheShkaW1zRFY/LnZhbHVlPy52YWx1ZSkgPyBkaW1zRFYudmFsdWUudmFsdWUgOiBbXSxcclxuICAgIH07XHJcbiAgICB0aGlzLl9tZXRhQ2FjaGUuc2V0KG5vZGVJZCwgbWV0YSk7XHJcbiAgICByZXR1cm4gbWV0YTtcclxuICB9XHJcblxyXG4gIF92YWxpZGF0ZVJhbmtBbmRTaGFwZSh2YWx1ZSwgbWV0YSkge1xyXG4gICAgaWYgKCFtZXRhKSByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG4gICAgY29uc3QgcmFuayA9IG1ldGEudmFsdWVSYW5rO1xyXG4gICAgaWYgKHJhbmsgPT0gbnVsbCB8fCByYW5rID09PSAtMSkge1xyXG4gICAgICAvLyBTY2FsYXIgZXhwZWN0ZWRcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnQmFkVHlwZU1pc21hdGNoOiBzY2FsYXIgZXhwZWN0ZWQnIH07XHJcbiAgICAgIHJldHVybiB7IG9rOiB0cnVlIH07XHJcbiAgICB9XHJcbiAgICAvLyBBcnJheSBleHBlY3RlZCAocmFuayA+PSAxKVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0JhZFR5cGVNaXNtYXRjaDogYXJyYXkgZXhwZWN0ZWQnIH07XHJcbiAgICAvLyBWYWxpZGF0ZSBkaW1lbnNpb24gbGVuZ3RocyBpZiBwcm92aWRlZCAoemVyb3MgbWVhbiB1bnNwZWNpZmllZClcclxuICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGEuYXJyYXlEaW1lbnNpb25zKSAmJiBtZXRhLmFycmF5RGltZW5zaW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IGZpeGVkRGltcyA9IG1ldGEuYXJyYXlEaW1lbnNpb25zLmV2ZXJ5KGQgPT4gdHlwZW9mIGQgPT09ICdudW1iZXInICYmIGQgPiAwKTtcclxuICAgICAgaWYgKGZpeGVkRGltcyAmJiBtZXRhLmFycmF5RGltZW5zaW9ucy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBtZXRhLmFycmF5RGltZW5zaW9uc1swXSkge1xyXG4gICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEJhZFR5cGVNaXNtYXRjaDogZXhwZWN0ZWQgbGVuZ3RoICR7bWV0YS5hcnJheURpbWVuc2lvbnNbMF19YCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBGb3IgbXVsdGktZGltIGFycmF5cywgdmFsaWRhdGlvbiB3b3VsZCBuZWVkIG5lc3RlZCBzaGFwZXM7IG9taXR0ZWQgZm9yIG5vdy5cclxuICAgIH1cclxuICAgIHJldHVybiB7IG9rOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBfY29lcmNlVmFyaWFudCh2YWwsIGR0KSB7XHJcbiAgICAvLyBJZiB2YWwgaXMgYWxyZWFkeSBhIFZhcmlhbnQsIHBhc3MgdGhyb3VnaFxyXG4gICAgaWYgKHZhbCAmJiB2YWwuZGF0YVR5cGUgIT09IHVuZGVmaW5lZCAmJiB2YWwudmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWFwID0ge1xyXG4gICAgICBCb29sZWFuOiBEYXRhVHlwZS5Cb29sZWFuLFxyXG4gICAgICBJbnQxNjogRGF0YVR5cGUuSW50MTYsXHJcbiAgICAgIEludDMyOiBEYXRhVHlwZS5JbnQzMixcclxuICAgICAgSW50NjQ6IERhdGFUeXBlLkludDY0LFxyXG4gICAgICBVSW50MTY6IERhdGFUeXBlLlVJbnQxNixcclxuICAgICAgVUludDMyOiBEYXRhVHlwZS5VSW50MzIsXHJcbiAgICAgIFVJbnQ2NDogRGF0YVR5cGUuVUludDY0LFxyXG4gICAgICBGbG9hdDogRGF0YVR5cGUuRmxvYXQsXHJcbiAgICAgIERvdWJsZTogRGF0YVR5cGUuRG91YmxlLFxyXG4gICAgICBTdHJpbmc6IERhdGFUeXBlLlN0cmluZyxcclxuICAgICAgRGF0ZVRpbWU6IERhdGFUeXBlLkRhdGVUaW1lLFxyXG4gICAgICBCeXRlU3RyaW5nOiBEYXRhVHlwZS5CeXRlU3RyaW5nLFxyXG4gICAgfTtcclxuICAgIGxldCBkYXRhVHlwZSA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChkdCAhPT0gdW5kZWZpbmVkICYmIGR0ICE9PSBudWxsKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZHQgPT09ICdudW1iZXInKSBkYXRhVHlwZSA9IGR0OyAvLyBhbHJlYWR5IGEgRGF0YVR5cGUgaWRcclxuICAgICAgZWxzZSBpZiAodHlwZW9mIGR0ID09PSAnc3RyaW5nJyAmJiBtYXBbZHRdICE9PSB1bmRlZmluZWQpIGRhdGFUeXBlID0gbWFwW2R0XTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbmZlciB3aGVuIG5vdCBwcm92aWRlZFxyXG4gICAgaWYgKGRhdGFUeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgIC8vIEluZmVyIGZyb20gZmlyc3QgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gdmFsWzBdO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3QgPT09ICdudW1iZXInKSBkYXRhVHlwZSA9IE51bWJlci5pc0ludGVnZXIoZmlyc3QpID8gRGF0YVR5cGUuSW50MzIgOiBEYXRhVHlwZS5Eb3VibGU7XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpcnN0ID09PSAnYm9vbGVhbicpIGRhdGFUeXBlID0gRGF0YVR5cGUuQm9vbGVhbjtcclxuICAgICAgICBlbHNlIGRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCBhcnJheVR5cGU6IFZhcmlhbnRBcnJheVR5cGUuQXJyYXksIHZhbHVlOiB2YWwgfSk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gSWYgc3RyaW5nIGJ1dCBudW1lcmljLWxpa2UsIGNvZXJjZSB0byBudW1iZXIgdG8gbWF0Y2ggY29tbW9uIHNjYWxhciB3cml0ZXNcclxuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uc3QgbWF5YmUgPSBOdW1iZXIodmFsKTtcclxuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKG1heWJlKSkge1xyXG4gICAgICAgICAgZGF0YVR5cGUgPSBOdW1iZXIuaXNJbnRlZ2VyKG1heWJlKSA/IERhdGFUeXBlLkludDMyIDogRGF0YVR5cGUuRG91YmxlO1xyXG4gICAgICAgICAgcmV0dXJuIG5ldyBWYXJpYW50KHsgZGF0YVR5cGUsIHZhbHVlOiBtYXliZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsKSB7XHJcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgIGRhdGFUeXBlID0gTnVtYmVyLmlzSW50ZWdlcih2YWwpID8gRGF0YVR5cGUuSW50MzIgOiBEYXRhVHlwZS5Eb3VibGU7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgICAgZGF0YVR5cGUgPSBEYXRhVHlwZS5Cb29sZWFuOyBicmVhaztcclxuICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgZGF0YVR5cGUgPSBEYXRhVHlwZS5TdHJpbmc7IGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBTdHJpbmdcclxuICAgICAgICAgIGRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCB2YWx1ZTogdmFsIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc3BlY3QgZXhwbGljaXQgZGF0YVR5cGUsIHN1cHBvcnQgYXJyYXlzIHdpdGggZWxlbWVudCBjb2VyY2lvblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICBjb25zdCBjb2VyY2VkQXJyID0gdmFsLm1hcCh2ID0+IHRoaXMuX2NvZXJjZUpzKHYsIGRhdGFUeXBlKSk7XHJcbiAgICAgIGxldCBhcnJWYWwgPSBjb2VyY2VkQXJyO1xyXG4gICAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XHJcbiAgICAgICAgY2FzZSBEYXRhVHlwZS5JbnQxNjogYXJyVmFsID0gSW50MTZBcnJheS5mcm9tKGNvZXJjZWRBcnIpOyBicmVhaztcclxuICAgICAgICBjYXNlIERhdGFUeXBlLkludDMyOiBhcnJWYWwgPSBJbnQzMkFycmF5LmZyb20oY29lcmNlZEFycik7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRGF0YVR5cGUuVUludDE2OiBhcnJWYWwgPSBVaW50MTZBcnJheS5mcm9tKGNvZXJjZWRBcnIpOyBicmVhaztcclxuICAgICAgICBjYXNlIERhdGFUeXBlLlVJbnQzMjogYXJyVmFsID0gVWludDMyQXJyYXkuZnJvbShjb2VyY2VkQXJyKTsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBEYXRhVHlwZS5GbG9hdDogYXJyVmFsID0gRmxvYXQzMkFycmF5LmZyb20oY29lcmNlZEFycik7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgRGF0YVR5cGUuRG91YmxlOiBhcnJWYWwgPSBGbG9hdDY0QXJyYXkuZnJvbShjb2VyY2VkQXJyKTsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDogLyogbGVhdmUgYXMgcGxhaW4gYXJyYXkgZm9yIDY0LWJpdCBhbmQgb3RoZXJzICovIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCBhcnJheVR5cGU6IFZhcmlhbnRBcnJheVR5cGUuQXJyYXksIHZhbHVlOiBhcnJWYWwgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjb2VyY2VkID0gdGhpcy5fY29lcmNlSnModmFsLCBkYXRhVHlwZSk7XHJcbiAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgdmFsdWU6IGNvZXJjZWQgfSk7XHJcbiAgfVxyXG5cclxuICBfY29lcmNlSnModmFsLCBkYXRhVHlwZSkge1xyXG4gICAgLy8gSWYgZGF0YVR5cGUgaXMgYSBudW1lcmljIGJ1aWx0LWluIGlkICgwLi5uKSwgbWFwIGl0IHRvIGVudW0gY29uc3RhbnRcclxuICAgIGlmICh0eXBlb2YgZGF0YVR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIC8vIGRhdGFUeXBlIGFscmVhZHkgbnVtZXJpYzsgZmFsbC10aHJvdWdoXHJcbiAgICB9XHJcbiAgICBzd2l0Y2ggKGRhdGFUeXBlKSB7XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuQm9vbGVhbjpcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiB2YWwudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKHZhbCk7XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuSW50MTY6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuSW50MzI6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuSW50NjQ6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuVUludDE2OlxyXG4gICAgICBjYXNlIERhdGFUeXBlLlVJbnQzMjpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5VSW50NjQ6XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gTWF0aC50cnVuYyhuKSA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmModmFsKTtcclxuICAgICAgY2FzZSBEYXRhVHlwZS5GbG9hdDpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5Eb3VibGU6XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG4pID8gbiA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWwpO1xyXG4gICAgICBjYXNlIERhdGFUeXBlLlN0cmluZzpcclxuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbCk7XHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT1BDVUFIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxNQUFNO0VBQUVBLFdBQVc7RUFBRUMsWUFBWTtFQUFFQyxtQkFBbUI7RUFBRUMsY0FBYztFQUFFQyxPQUFPO0VBQUVDLGdCQUFnQjtFQUFFQztBQUFTLENBQUMsR0FBR0MsT0FBTyxDQUFDLFlBQVksQ0FBQztBQUVySSxNQUFNQyxZQUFZLENBQUM7RUFDakJDLFdBQVdBLENBQUNDLFlBQVksRUFBRUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQ3JDLElBQUksQ0FBQ0QsWUFBWSxHQUFHQSxZQUFZO0lBQ2hDLElBQUksQ0FBQ0MsTUFBTSxHQUFHQSxNQUFNO0lBQ3BCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUk7SUFDbEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSTtJQUNuQixJQUFJLENBQUNDLFdBQVcsR0FBRyxLQUFLO0lBQ3hCO0lBQ0EsSUFBSSxDQUFDQyxVQUFVLEdBQUcsSUFBSUMsR0FBRyxDQUFDLENBQUM7RUFDN0I7RUFFQSxNQUFNQyxPQUFPQSxDQUFBLEVBQUc7SUFDZCxNQUFNQyxXQUFXLEdBQUcsSUFBSSxDQUFDUCxNQUFNLENBQUNPLFdBQVc7SUFDM0MsSUFBSSxDQUFDQSxXQUFXLEVBQUUsTUFBTSxJQUFJQyxLQUFLLENBQUMsZ0NBQWdDLENBQUM7SUFFbkUsTUFBTVAsTUFBTSxHQUFHWixXQUFXLENBQUNvQixNQUFNLENBQUM7TUFDaENDLGVBQWUsRUFBRSx1QkFBdUI7TUFDeENDLFlBQVksRUFBRXBCLG1CQUFtQixDQUFDcUIsSUFBSTtNQUN0Q0MsY0FBYyxFQUFFckIsY0FBYyxDQUFDb0IsSUFBSTtNQUNuQ0UsaUJBQWlCLEVBQUUsS0FBSztNQUN4QkMsa0JBQWtCLEVBQUU7UUFBRUMsWUFBWSxFQUFFLEdBQUc7UUFBRUMsUUFBUSxFQUFFO01BQUU7SUFDdkQs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