7a3216742de94a139a093385c0b8799a
// server/handlers/opcua_handler.js
const {
  OPCUAClient,
  AttributeIds,
  MessageSecurityMode,
  SecurityPolicy,
  Variant,
  VariantArrayType,
  DataType
} = require('node-opcua');
class OPCUAHandler {
  constructor(connectionId, config = {}) {
    this.connectionId = connectionId;
    this.config = config;
    this.client = null;
    this.session = null;
    this.isConnected = false;
    // Cache of node metadata: { dataType, valueRank, arrayDimensions }
    this._metaCache = new Map();
  }
  async connect() {
    const endpointUrl = this.config.endpointUrl;
    if (!endpointUrl) throw new Error('OPC UA endpointUrl is required');
    const client = OPCUAClient.create({
      applicationName: 'Universal Test Client',
      securityMode: MessageSecurityMode.None,
      securityPolicy: SecurityPolicy.None,
      endpointMustExist: false,
      connectionStrategy: {
        initialDelay: 250,
        maxRetry: 1
      }
    });
    const timeoutMs = Number(this.config.timeoutMs || 5000);
    const connectPromise = client.connect(endpointUrl);
    const timed = new Promise((_, reject) => setTimeout(() => reject(new Error('OPC UA connect timeout')), timeoutMs));
    await Promise.race([connectPromise, timed]);
    const session = await client.createSession();
    this.client = client;
    this.session = session;
    this.isConnected = true;
    return {
      success: true
    };
  }
  async disconnect() {
    try {
      if (this.session) await this.session.close();
    } catch {}
    try {
      if (this.client) await this.client.disconnect();
    } catch {}
    this.client = null;
    this.session = null;
    this.isConnected = false;
    this._metaCache.clear();
    return {
      success: true
    };
  }
  async browse(nodeId = 'RootFolder') {
    if (!this.session) throw new Error('Not connected');
    const result = await this.session.browse(nodeId);
    return {
      success: true,
      data: result.references || []
    };
  }
  async read(nodes) {
    if (!this.session) throw new Error('Not connected');
    const nodesToRead = (Array.isArray(nodes) ? nodes : [nodes]).map(n => ({
      nodeId: n,
      attributeId: AttributeIds.Value
    }));
    const dataValues = await this.session.read(nodesToRead);
    return {
      success: true,
      data: dataValues
    };
  }
  async write(nodeId, value, dataType = null) {
    if (!this.session) throw new Error('Not connected');
    if (!nodeId) throw new Error('nodeId is required');

    // Fetch and cache node meta (datatype, valueRank, arrayDimensions)
    const meta = await this._getNodeMeta(nodeId);

    // Choose dataType: explicit > meta-inferred > heuristic
    let dt = dataType ?? meta?.dataType;

    // Validate rank/shape before coercion/write
    const rankCheck = this._validateRankAndShape(value, meta);
    if (!rankCheck.ok) {
      return {
        success: false,
        error: rankCheck.error
      };
    }
    const variant = this._coerceVariant(value, dt);
    const statusCode = await this.session.writeSingleNode(nodeId, variant);
    const scStr = statusCode?.name || String(statusCode || '');
    let ok = !!statusCode && (statusCode.value === 0 || scStr.includes('Good'));

    // Fallback: element-wise writes for arrays when server rejects typed arrays
    if (!ok && Array.isArray(value)) {
      const writes = value.map((el, i) => ({
        nodeId,
        attributeId: AttributeIds.Value,
        indexRange: String(i),
        value: {
          value: this._coerceVariant(el, dataType)
        }
      }));
      const results = await this.session.write(writes);
      ok = Array.isArray(results) && results.every(rc => rc && (rc.value === 0 || (rc.name || '').includes('Good')));
      return {
        success: ok,
        statusCodes: results.map(r => r?.name || String(r || ''))
      };
    }
    return {
      success: ok,
      statusCode: scStr
    };
  }
  async _inferDataTypeForNode(nodeId) {
    const dv = await this.session.read({
      nodeId,
      attributeId: AttributeIds.DataType
    });
    const dtNodeId = dv?.value?.value;
    if (dtNodeId && dtNodeId.namespace === 0 && typeof dtNodeId.value === 'number') {
      return dtNodeId.value;
    }
    // Fallback: read current value's variant to infer dataType
    const valDV = await this.session.read({
      nodeId,
      attributeId: AttributeIds.Value
    });
    const vt = valDV?.value?.dataType;
    if (typeof vt === 'number') return vt;
    return undefined;
  }
  async _getNodeMeta(nodeId) {
    if (this._metaCache.has(nodeId)) return this._metaCache.get(nodeId);
    const toRead = [{
      nodeId,
      attributeId: AttributeIds.DataType
    }, {
      nodeId,
      attributeId: AttributeIds.ValueRank
    }, {
      nodeId,
      attributeId: AttributeIds.ArrayDimensions
    }];
    const [dtDV, rankDV, dimsDV] = await this.session.read(toRead);
    const meta = {
      dataType: dtDV?.value?.value && dtDV.value.value.namespace === 0 ? dtDV.value.value.value : undefined,
      valueRank: typeof rankDV?.value?.value === 'number' ? rankDV.value.value : -1,
      arrayDimensions: Array.isArray(dimsDV?.value?.value) ? dimsDV.value.value : []
    };
    this._metaCache.set(nodeId, meta);
    return meta;
  }
  _validateRankAndShape(value, meta) {
    if (!meta) return {
      ok: true
    };
    const rank = meta.valueRank;
    if (rank == null || rank === -1) {
      // Scalar expected
      if (Array.isArray(value)) return {
        ok: false,
        error: 'BadTypeMismatch: scalar expected'
      };
      return {
        ok: true
      };
    }
    // Array expected (rank >= 1)
    if (!Array.isArray(value)) return {
      ok: false,
      error: 'BadTypeMismatch: array expected'
    };
    // Validate dimension lengths if provided (zeros mean unspecified)
    if (Array.isArray(meta.arrayDimensions) && meta.arrayDimensions.length > 0) {
      const fixedDims = meta.arrayDimensions.every(d => typeof d === 'number' && d > 0);
      if (fixedDims && meta.arrayDimensions.length === 1) {
        if (value.length !== meta.arrayDimensions[0]) {
          return {
            ok: false,
            error: `BadTypeMismatch: expected length ${meta.arrayDimensions[0]}`
          };
        }
      }
      // For multi-dim arrays, validation would need nested shapes; omitted for now.
    }
    return {
      ok: true
    };
  }
  _coerceVariant(val, dt) {
    // If val is already a Variant, pass through
    if (val && val.dataType !== undefined && val.value !== undefined) {
      return val;
    }
    const map = {
      Boolean: DataType.Boolean,
      Int16: DataType.Int16,
      Int32: DataType.Int32,
      Int64: DataType.Int64,
      UInt16: DataType.UInt16,
      UInt32: DataType.UInt32,
      UInt64: DataType.UInt64,
      Float: DataType.Float,
      Double: DataType.Double,
      String: DataType.String,
      DateTime: DataType.DateTime,
      ByteString: DataType.ByteString
    };
    let dataType = undefined;
    if (dt !== undefined && dt !== null) {
      if (typeof dt === 'number') dataType = dt; // already a DataType id
      else if (typeof dt === 'string' && map[dt] !== undefined) dataType = map[dt];
    }

    // Infer when not provided
    if (dataType === undefined) {
      if (Array.isArray(val)) {
        // Infer from first element
        const first = val[0];
        if (typeof first === 'number') dataType = Number.isInteger(first) ? DataType.Int32 : DataType.Double;else if (typeof first === 'boolean') dataType = DataType.Boolean;else dataType = DataType.String;
        return new Variant({
          dataType,
          arrayType: VariantArrayType.Array,
          value: val
        });
      }
      // If string but numeric-like, coerce to number to match common scalar writes
      if (typeof val === 'string') {
        const maybe = Number(val);
        if (Number.isFinite(maybe)) {
          dataType = Number.isInteger(maybe) ? DataType.Int32 : DataType.Double;
          return new Variant({
            dataType,
            value: maybe
          });
        }
      }
      switch (typeof val) {
        case 'number':
          dataType = Number.isInteger(val) ? DataType.Int32 : DataType.Double;
          break;
        case 'boolean':
          dataType = DataType.Boolean;
          break;
        case 'string':
          dataType = DataType.String;
          break;
        default:
          // Fallback to String
          dataType = DataType.String;
      }
      return new Variant({
        dataType,
        value: val
      });
    }

    // Respect explicit dataType, support arrays with element coercion
    if (Array.isArray(val)) {
      const coercedArr = val.map(v => this._coerceJs(v, dataType));
      return new Variant({
        dataType,
        arrayType: VariantArrayType.Array,
        value: coercedArr
      });
    }
    const coerced = this._coerceJs(val, dataType);
    return new Variant({
      dataType,
      value: coerced
    });
  }
  _coerceJs(val, dataType) {
    // If dataType is a numeric built-in id (0..n), map it to enum constant
    if (typeof dataType === 'number') {
      // dataType already numeric; fall-through
    }
    switch (dataType) {
      case DataType.Boolean:
        if (typeof val === 'string') return val.toLowerCase() === 'true';
        return Boolean(val);
      case DataType.Int16:
      case DataType.Int32:
      case DataType.Int64:
      case DataType.UInt16:
      case DataType.UInt32:
      case DataType.UInt64:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? Math.trunc(n) : val;
        }
        return Math.trunc(val);
      case DataType.Float:
      case DataType.Double:
        if (typeof val === 'string') {
          const n = Number(val);
          return Number.isFinite(n) ? n : val;
        }
        return Number(val);
      case DataType.String:
        return String(val);
      default:
        return val;
    }
  }
}
module.exports = OPCUAHandler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPUENVQUNsaWVudCIsIkF0dHJpYnV0ZUlkcyIsIk1lc3NhZ2VTZWN1cml0eU1vZGUiLCJTZWN1cml0eVBvbGljeSIsIlZhcmlhbnQiLCJWYXJpYW50QXJyYXlUeXBlIiwiRGF0YVR5cGUiLCJyZXF1aXJlIiwiT1BDVUFIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb25uZWN0aW9uSWQiLCJjb25maWciLCJjbGllbnQiLCJzZXNzaW9uIiwiaXNDb25uZWN0ZWQiLCJfbWV0YUNhY2hlIiwiTWFwIiwiY29ubmVjdCIsImVuZHBvaW50VXJsIiwiRXJyb3IiLCJjcmVhdGUiLCJhcHBsaWNhdGlvbk5hbWUiLCJzZWN1cml0eU1vZGUiLCJOb25lIiwic2VjdXJpdHlQb2xpY3kiLCJlbmRwb2ludE11c3RFeGlzdCIsImNvbm5lY3Rpb25TdHJhdGVneSIsImluaXRpYWxEZWxheSIsIm1heFJldHJ5IiwidGltZW91dE1zIiwiTnVtYmVyIiwiY29ubmVjdFByb21pc2UiLCJ0aW1lZCIsIlByb21pc2UiLCJfIiwicmVqZWN0Iiwic2V0VGltZW91dCIsInJhY2UiLCJjcmVhdGVTZXNzaW9uIiwic3VjY2VzcyIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsImNsZWFyIiwiYnJvd3NlIiwibm9kZUlkIiwicmVzdWx0IiwiZGF0YSIsInJlZmVyZW5jZXMiLCJyZWFkIiwibm9kZXMiLCJub2Rlc1RvUmVhZCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm4iLCJhdHRyaWJ1dGVJZCIsIlZhbHVlIiwiZGF0YVZhbHVlcyIsIndyaXRlIiwidmFsdWUiLCJkYXRhVHlwZSIsIm1ldGEiLCJfZ2V0Tm9kZU1ldGEiLCJkdCIsInJhbmtDaGVjayIsIl92YWxpZGF0ZVJhbmtBbmRTaGFwZSIsIm9rIiwiZXJyb3IiLCJ2YXJpYW50IiwiX2NvZXJjZVZhcmlhbnQiLCJzdGF0dXNDb2RlIiwid3JpdGVTaW5nbGVOb2RlIiwic2NTdHIiLCJuYW1lIiwiU3RyaW5nIiwiaW5jbHVkZXMiLCJ3cml0ZXMiLCJlbCIsImkiLCJpbmRleFJhbmdlIiwicmVzdWx0cyIsImV2ZXJ5IiwicmMiLCJzdGF0dXNDb2RlcyIsInIiLCJfaW5mZXJEYXRhVHlwZUZvck5vZGUiLCJkdiIsImR0Tm9kZUlkIiwibmFtZXNwYWNlIiwidmFsRFYiLCJ2dCIsInVuZGVmaW5lZCIsImhhcyIsImdldCIsInRvUmVhZCIsIlZhbHVlUmFuayIsIkFycmF5RGltZW5zaW9ucyIsImR0RFYiLCJyYW5rRFYiLCJkaW1zRFYiLCJ2YWx1ZVJhbmsiLCJhcnJheURpbWVuc2lvbnMiLCJzZXQiLCJyYW5rIiwibGVuZ3RoIiwiZml4ZWREaW1zIiwiZCIsInZhbCIsIkJvb2xlYW4iLCJJbnQxNiIsIkludDMyIiwiSW50NjQiLCJVSW50MTYiLCJVSW50MzIiLCJVSW50NjQiLCJGbG9hdCIsIkRvdWJsZSIsIkRhdGVUaW1lIiwiQnl0ZVN0cmluZyIsImZpcnN0IiwiaXNJbnRlZ2VyIiwiYXJyYXlUeXBlIiwibWF5YmUiLCJpc0Zpbml0ZSIsImNvZXJjZWRBcnIiLCJ2IiwiX2NvZXJjZUpzIiwiY29lcmNlZCIsInRvTG93ZXJDYXNlIiwiTWF0aCIsInRydW5jIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VzIjpbIm9wY3VhX2hhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2VydmVyL2hhbmRsZXJzL29wY3VhX2hhbmRsZXIuanNcclxuY29uc3QgeyBPUENVQUNsaWVudCwgQXR0cmlidXRlSWRzLCBNZXNzYWdlU2VjdXJpdHlNb2RlLCBTZWN1cml0eVBvbGljeSwgVmFyaWFudCwgVmFyaWFudEFycmF5VHlwZSwgRGF0YVR5cGUgfSA9IHJlcXVpcmUoJ25vZGUtb3BjdWEnKTtcclxuXHJcbmNsYXNzIE9QQ1VBSGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbklkLCBjb25maWcgPSB7fSkge1xyXG4gICAgdGhpcy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XHJcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XHJcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAvLyBDYWNoZSBvZiBub2RlIG1ldGFkYXRhOiB7IGRhdGFUeXBlLCB2YWx1ZVJhbmssIGFycmF5RGltZW5zaW9ucyB9XHJcbiAgICB0aGlzLl9tZXRhQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBjb25uZWN0KCkge1xyXG4gICAgY29uc3QgZW5kcG9pbnRVcmwgPSB0aGlzLmNvbmZpZy5lbmRwb2ludFVybDtcclxuICAgIGlmICghZW5kcG9pbnRVcmwpIHRocm93IG5ldyBFcnJvcignT1BDIFVBIGVuZHBvaW50VXJsIGlzIHJlcXVpcmVkJyk7XHJcblxyXG4gICAgY29uc3QgY2xpZW50ID0gT1BDVUFDbGllbnQuY3JlYXRlKHtcclxuICAgICAgYXBwbGljYXRpb25OYW1lOiAnVW5pdmVyc2FsIFRlc3QgQ2xpZW50JyxcclxuICAgICAgc2VjdXJpdHlNb2RlOiBNZXNzYWdlU2VjdXJpdHlNb2RlLk5vbmUsXHJcbiAgICAgIHNlY3VyaXR5UG9saWN5OiBTZWN1cml0eVBvbGljeS5Ob25lLFxyXG4gICAgICBlbmRwb2ludE11c3RFeGlzdDogZmFsc2UsXHJcbiAgICAgIGNvbm5lY3Rpb25TdHJhdGVneTogeyBpbml0aWFsRGVsYXk6IDI1MCwgbWF4UmV0cnk6IDEgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdGltZW91dE1zID0gTnVtYmVyKHRoaXMuY29uZmlnLnRpbWVvdXRNcyB8fCA1MDAwKTtcclxuICAgIGNvbnN0IGNvbm5lY3RQcm9taXNlID0gY2xpZW50LmNvbm5lY3QoZW5kcG9pbnRVcmwpO1xyXG4gICAgY29uc3QgdGltZWQgPSBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ09QQyBVQSBjb25uZWN0IHRpbWVvdXQnKSksIHRpbWVvdXRNcykpO1xyXG4gICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtjb25uZWN0UHJvbWlzZSwgdGltZWRdKTtcclxuXHJcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgY2xpZW50LmNyZWF0ZVNlc3Npb24oKTtcclxuXHJcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcclxuICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XHJcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBkaXNjb25uZWN0KCkge1xyXG4gICAgdHJ5IHsgaWYgKHRoaXMuc2Vzc2lvbikgYXdhaXQgdGhpcy5zZXNzaW9uLmNsb3NlKCk7IH0gY2F0Y2gge31cclxuICAgIHRyeSB7IGlmICh0aGlzLmNsaWVudCkgYXdhaXQgdGhpcy5jbGllbnQuZGlzY29ubmVjdCgpOyB9IGNhdGNoIHt9XHJcbiAgICB0aGlzLmNsaWVudCA9IG51bGw7XHJcbiAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xyXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbWV0YUNhY2hlLmNsZWFyKCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBicm93c2Uobm9kZUlkID0gJ1Jvb3RGb2xkZXInKSB7XHJcbiAgICBpZiAoIXRoaXMuc2Vzc2lvbikgdGhyb3cgbmV3IEVycm9yKCdOb3QgY29ubmVjdGVkJyk7XHJcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlc3Npb24uYnJvd3NlKG5vZGVJZCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQucmVmZXJlbmNlcyB8fCBbXSB9O1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgcmVhZChub2Rlcykge1xyXG4gICAgaWYgKCF0aGlzLnNlc3Npb24pIHRocm93IG5ldyBFcnJvcignTm90IGNvbm5lY3RlZCcpO1xyXG4gICAgY29uc3Qgbm9kZXNUb1JlYWQgPSAoQXJyYXkuaXNBcnJheShub2RlcykgPyBub2RlcyA6IFtub2Rlc10pLm1hcCgobikgPT4gKHsgbm9kZUlkOiBuLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLlZhbHVlIH0pKTtcclxuICAgIGNvbnN0IGRhdGFWYWx1ZXMgPSBhd2FpdCB0aGlzLnNlc3Npb24ucmVhZChub2Rlc1RvUmVhZCk7XHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBkYXRhVmFsdWVzIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyB3cml0ZShub2RlSWQsIHZhbHVlLCBkYXRhVHlwZSA9IG51bGwpIHtcclxuICAgIGlmICghdGhpcy5zZXNzaW9uKSB0aHJvdyBuZXcgRXJyb3IoJ05vdCBjb25uZWN0ZWQnKTtcclxuICAgIGlmICghbm9kZUlkKSB0aHJvdyBuZXcgRXJyb3IoJ25vZGVJZCBpcyByZXF1aXJlZCcpO1xyXG5cclxuICAgIC8vIEZldGNoIGFuZCBjYWNoZSBub2RlIG1ldGEgKGRhdGF0eXBlLCB2YWx1ZVJhbmssIGFycmF5RGltZW5zaW9ucylcclxuICAgIGNvbnN0IG1ldGEgPSBhd2FpdCB0aGlzLl9nZXROb2RlTWV0YShub2RlSWQpO1xyXG5cclxuICAgIC8vIENob29zZSBkYXRhVHlwZTogZXhwbGljaXQgPiBtZXRhLWluZmVycmVkID4gaGV1cmlzdGljXHJcbiAgICBsZXQgZHQgPSBkYXRhVHlwZSA/PyBtZXRhPy5kYXRhVHlwZTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSByYW5rL3NoYXBlIGJlZm9yZSBjb2VyY2lvbi93cml0ZVxyXG4gICAgY29uc3QgcmFua0NoZWNrID0gdGhpcy5fdmFsaWRhdGVSYW5rQW5kU2hhcGUodmFsdWUsIG1ldGEpO1xyXG4gICAgaWYgKCFyYW5rQ2hlY2sub2spIHtcclxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByYW5rQ2hlY2suZXJyb3IgfTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB2YXJpYW50ID0gdGhpcy5fY29lcmNlVmFyaWFudCh2YWx1ZSwgZHQpO1xyXG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IGF3YWl0IHRoaXMuc2Vzc2lvbi53cml0ZVNpbmdsZU5vZGUobm9kZUlkLCB2YXJpYW50KTtcclxuICAgIGNvbnN0IHNjU3RyID0gc3RhdHVzQ29kZT8ubmFtZSB8fCBTdHJpbmcoc3RhdHVzQ29kZSB8fCAnJyk7XHJcbiAgICBsZXQgb2sgPSAhIXN0YXR1c0NvZGUgJiYgKHN0YXR1c0NvZGUudmFsdWUgPT09IDAgfHwgc2NTdHIuaW5jbHVkZXMoJ0dvb2QnKSk7XHJcblxyXG4gICAgLy8gRmFsbGJhY2s6IGVsZW1lbnQtd2lzZSB3cml0ZXMgZm9yIGFycmF5cyB3aGVuIHNlcnZlciByZWplY3RzIHR5cGVkIGFycmF5c1xyXG4gICAgaWYgKCFvayAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICBjb25zdCB3cml0ZXMgPSB2YWx1ZS5tYXAoKGVsLCBpKSA9PiAoe1xyXG4gICAgICAgIG5vZGVJZCxcclxuICAgICAgICBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLlZhbHVlLFxyXG4gICAgICAgIGluZGV4UmFuZ2U6IFN0cmluZyhpKSxcclxuICAgICAgICB2YWx1ZTogeyB2YWx1ZTogdGhpcy5fY29lcmNlVmFyaWFudChlbCwgZGF0YVR5cGUpIH1cclxuICAgICAgfSkpO1xyXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5zZXNzaW9uLndyaXRlKHdyaXRlcyk7XHJcbiAgICAgIG9rID0gQXJyYXkuaXNBcnJheShyZXN1bHRzKSAmJiByZXN1bHRzLmV2ZXJ5KHJjID0+IHJjICYmIChyYy52YWx1ZSA9PT0gMCB8fCAocmMubmFtZXx8JycpLmluY2x1ZGVzKCdHb29kJykpKTtcclxuICAgICAgcmV0dXJuIHsgc3VjY2Vzczogb2ssIHN0YXR1c0NvZGVzOiByZXN1bHRzLm1hcChyID0+IHI/Lm5hbWUgfHwgU3RyaW5nKHJ8fCcnKSkgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiBvaywgc3RhdHVzQ29kZTogc2NTdHIgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIF9pbmZlckRhdGFUeXBlRm9yTm9kZShub2RlSWQpIHtcclxuICAgIGNvbnN0IGR2ID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQoeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuRGF0YVR5cGUgfSk7XHJcbiAgICBjb25zdCBkdE5vZGVJZCA9IGR2Py52YWx1ZT8udmFsdWU7XHJcbiAgICBpZiAoZHROb2RlSWQgJiYgZHROb2RlSWQubmFtZXNwYWNlID09PSAwICYmIHR5cGVvZiBkdE5vZGVJZC52YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgcmV0dXJuIGR0Tm9kZUlkLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gRmFsbGJhY2s6IHJlYWQgY3VycmVudCB2YWx1ZSdzIHZhcmlhbnQgdG8gaW5mZXIgZGF0YVR5cGVcclxuICAgIGNvbnN0IHZhbERWID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQoeyBub2RlSWQsIGF0dHJpYnV0ZUlkOiBBdHRyaWJ1dGVJZHMuVmFsdWUgfSk7XHJcbiAgICBjb25zdCB2dCA9IHZhbERWPy52YWx1ZT8uZGF0YVR5cGU7XHJcbiAgICBpZiAodHlwZW9mIHZ0ID09PSAnbnVtYmVyJykgcmV0dXJuIHZ0O1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIGFzeW5jIF9nZXROb2RlTWV0YShub2RlSWQpIHtcclxuICAgIGlmICh0aGlzLl9tZXRhQ2FjaGUuaGFzKG5vZGVJZCkpIHJldHVybiB0aGlzLl9tZXRhQ2FjaGUuZ2V0KG5vZGVJZCk7XHJcbiAgICBjb25zdCB0b1JlYWQgPSBbXHJcbiAgICAgIHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLkRhdGFUeXBlIH0sXHJcbiAgICAgIHsgbm9kZUlkLCBhdHRyaWJ1dGVJZDogQXR0cmlidXRlSWRzLlZhbHVlUmFuayB9LFxyXG4gICAgICB7IG5vZGVJZCwgYXR0cmlidXRlSWQ6IEF0dHJpYnV0ZUlkcy5BcnJheURpbWVuc2lvbnMgfSxcclxuICAgIF07XHJcbiAgICBjb25zdCBbZHREViwgcmFua0RWLCBkaW1zRFZdID0gYXdhaXQgdGhpcy5zZXNzaW9uLnJlYWQodG9SZWFkKTtcclxuICAgIGNvbnN0IG1ldGEgPSB7XHJcbiAgICAgIGRhdGFUeXBlOiAoZHREVj8udmFsdWU/LnZhbHVlICYmIGR0RFYudmFsdWUudmFsdWUubmFtZXNwYWNlID09PSAwKSA/IGR0RFYudmFsdWUudmFsdWUudmFsdWUgOiB1bmRlZmluZWQsXHJcbiAgICAgIHZhbHVlUmFuazogdHlwZW9mIHJhbmtEVj8udmFsdWU/LnZhbHVlID09PSAnbnVtYmVyJyA/IHJhbmtEVi52YWx1ZS52YWx1ZSA6IC0xLFxyXG4gICAgICBhcnJheURpbWVuc2lvbnM6IEFycmF5LmlzQXJyYXkoZGltc0RWPy52YWx1ZT8udmFsdWUpID8gZGltc0RWLnZhbHVlLnZhbHVlIDogW10sXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fbWV0YUNhY2hlLnNldChub2RlSWQsIG1ldGEpO1xyXG4gICAgcmV0dXJuIG1ldGE7XHJcbiAgfVxyXG5cclxuICBfdmFsaWRhdGVSYW5rQW5kU2hhcGUodmFsdWUsIG1ldGEpIHtcclxuICAgIGlmICghbWV0YSkgcmV0dXJuIHsgb2s6IHRydWUgfTtcclxuICAgIGNvbnN0IHJhbmsgPSBtZXRhLnZhbHVlUmFuaztcclxuICAgIGlmIChyYW5rID09IG51bGwgfHwgcmFuayA9PT0gLTEpIHtcclxuICAgICAgLy8gU2NhbGFyIGV4cGVjdGVkXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogJ0JhZFR5cGVNaXNtYXRjaDogc2NhbGFyIGV4cGVjdGVkJyB9O1xyXG4gICAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG4gICAgfVxyXG4gICAgLy8gQXJyYXkgZXhwZWN0ZWQgKHJhbmsgPj0gMSlcclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdCYWRUeXBlTWlzbWF0Y2g6IGFycmF5IGV4cGVjdGVkJyB9O1xyXG4gICAgLy8gVmFsaWRhdGUgZGltZW5zaW9uIGxlbmd0aHMgaWYgcHJvdmlkZWQgKHplcm9zIG1lYW4gdW5zcGVjaWZpZWQpXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShtZXRhLmFycmF5RGltZW5zaW9ucykgJiYgbWV0YS5hcnJheURpbWVuc2lvbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBjb25zdCBmaXhlZERpbXMgPSBtZXRhLmFycmF5RGltZW5zaW9ucy5ldmVyeShkID0+IHR5cGVvZiBkID09PSAnbnVtYmVyJyAmJiBkID4gMCk7XHJcbiAgICAgIGlmIChmaXhlZERpbXMgJiYgbWV0YS5hcnJheURpbWVuc2lvbnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gbWV0YS5hcnJheURpbWVuc2lvbnNbMF0pIHtcclxuICAgICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGBCYWRUeXBlTWlzbWF0Y2g6IGV4cGVjdGVkIGxlbmd0aCAke21ldGEuYXJyYXlEaW1lbnNpb25zWzBdfWAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gRm9yIG11bHRpLWRpbSBhcnJheXMsIHZhbGlkYXRpb24gd291bGQgbmVlZCBuZXN0ZWQgc2hhcGVzOyBvbWl0dGVkIGZvciBub3cuXHJcbiAgICB9XHJcbiAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgX2NvZXJjZVZhcmlhbnQodmFsLCBkdCkge1xyXG4gICAgLy8gSWYgdmFsIGlzIGFscmVhZHkgYSBWYXJpYW50LCBwYXNzIHRocm91Z2hcclxuICAgIGlmICh2YWwgJiYgdmFsLmRhdGFUeXBlICE9PSB1bmRlZmluZWQgJiYgdmFsLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGNvbnN0IG1hcCA9IHtcclxuICAgICAgQm9vbGVhbjogRGF0YVR5cGUuQm9vbGVhbixcclxuICAgICAgSW50MTY6IERhdGFUeXBlLkludDE2LFxyXG4gICAgICBJbnQzMjogRGF0YVR5cGUuSW50MzIsXHJcbiAgICAgIEludDY0OiBEYXRhVHlwZS5JbnQ2NCxcclxuICAgICAgVUludDE2OiBEYXRhVHlwZS5VSW50MTYsXHJcbiAgICAgIFVJbnQzMjogRGF0YVR5cGUuVUludDMyLFxyXG4gICAgICBVSW50NjQ6IERhdGFUeXBlLlVJbnQ2NCxcclxuICAgICAgRmxvYXQ6IERhdGFUeXBlLkZsb2F0LFxyXG4gICAgICBEb3VibGU6IERhdGFUeXBlLkRvdWJsZSxcclxuICAgICAgU3RyaW5nOiBEYXRhVHlwZS5TdHJpbmcsXHJcbiAgICAgIERhdGVUaW1lOiBEYXRhVHlwZS5EYXRlVGltZSxcclxuICAgICAgQnl0ZVN0cmluZzogRGF0YVR5cGUuQnl0ZVN0cmluZyxcclxuICAgIH07XHJcbiAgICBsZXQgZGF0YVR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoZHQgIT09IHVuZGVmaW5lZCAmJiBkdCAhPT0gbnVsbCkge1xyXG4gICAgICBpZiAodHlwZW9mIGR0ID09PSAnbnVtYmVyJykgZGF0YVR5cGUgPSBkdDsgLy8gYWxyZWFkeSBhIERhdGFUeXBlIGlkXHJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBkdCA9PT0gJ3N0cmluZycgJiYgbWFwW2R0XSAhPT0gdW5kZWZpbmVkKSBkYXRhVHlwZSA9IG1hcFtkdF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5mZXIgd2hlbiBub3QgcHJvdmlkZWRcclxuICAgIGlmIChkYXRhVHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAvLyBJbmZlciBmcm9tIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICBjb25zdCBmaXJzdCA9IHZhbFswXTtcclxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0ID09PSAnbnVtYmVyJykgZGF0YVR5cGUgPSBOdW1iZXIuaXNJbnRlZ2VyKGZpcnN0KSA/IERhdGFUeXBlLkludDMyIDogRGF0YVR5cGUuRG91YmxlO1xyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ2Jvb2xlYW4nKSBkYXRhVHlwZSA9IERhdGFUeXBlLkJvb2xlYW47XHJcbiAgICAgICAgZWxzZSBkYXRhVHlwZSA9IERhdGFUeXBlLlN0cmluZztcclxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgYXJyYXlUeXBlOiBWYXJpYW50QXJyYXlUeXBlLkFycmF5LCB2YWx1ZTogdmFsIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIElmIHN0cmluZyBidXQgbnVtZXJpYy1saWtlLCBjb2VyY2UgdG8gbnVtYmVyIHRvIG1hdGNoIGNvbW1vbiBzY2FsYXIgd3JpdGVzXHJcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGNvbnN0IG1heWJlID0gTnVtYmVyKHZhbCk7XHJcbiAgICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShtYXliZSkpIHtcclxuICAgICAgICAgIGRhdGFUeXBlID0gTnVtYmVyLmlzSW50ZWdlcihtYXliZSkgPyBEYXRhVHlwZS5JbnQzMiA6IERhdGFUeXBlLkRvdWJsZTtcclxuICAgICAgICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCB2YWx1ZTogbWF5YmUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbCkge1xyXG4gICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICBkYXRhVHlwZSA9IE51bWJlci5pc0ludGVnZXIodmFsKSA/IERhdGFUeXBlLkludDMyIDogRGF0YVR5cGUuRG91YmxlOyBicmVhaztcclxuICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgIGRhdGFUeXBlID0gRGF0YVR5cGUuQm9vbGVhbjsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgIGRhdGFUeXBlID0gRGF0YVR5cGUuU3RyaW5nOyBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gU3RyaW5nXHJcbiAgICAgICAgICBkYXRhVHlwZSA9IERhdGFUeXBlLlN0cmluZztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgdmFsdWU6IHZhbCB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNwZWN0IGV4cGxpY2l0IGRhdGFUeXBlLCBzdXBwb3J0IGFycmF5cyB3aXRoIGVsZW1lbnQgY29lcmNpb25cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgY29uc3QgY29lcmNlZEFyciA9IHZhbC5tYXAodiA9PiB0aGlzLl9jb2VyY2VKcyh2LCBkYXRhVHlwZSkpO1xyXG4gICAgICByZXR1cm4gbmV3IFZhcmlhbnQoeyBkYXRhVHlwZSwgYXJyYXlUeXBlOiBWYXJpYW50QXJyYXlUeXBlLkFycmF5LCB2YWx1ZTogY29lcmNlZEFyciB9KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNvZXJjZWQgPSB0aGlzLl9jb2VyY2VKcyh2YWwsIGRhdGFUeXBlKTtcclxuICAgIHJldHVybiBuZXcgVmFyaWFudCh7IGRhdGFUeXBlLCB2YWx1ZTogY29lcmNlZCB9KTtcclxuICB9XHJcblxyXG4gIF9jb2VyY2VKcyh2YWwsIGRhdGFUeXBlKSB7XHJcbiAgICAvLyBJZiBkYXRhVHlwZSBpcyBhIG51bWVyaWMgYnVpbHQtaW4gaWQgKDAuLm4pLCBtYXAgaXQgdG8gZW51bSBjb25zdGFudFxyXG4gICAgaWYgKHR5cGVvZiBkYXRhVHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgLy8gZGF0YVR5cGUgYWxyZWFkeSBudW1lcmljOyBmYWxsLXRocm91Z2hcclxuICAgIH1cclxuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcclxuICAgICAgY2FzZSBEYXRhVHlwZS5Cb29sZWFuOlxyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbC50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsKTtcclxuICAgICAgY2FzZSBEYXRhVHlwZS5JbnQxNjpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5JbnQzMjpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5JbnQ2NDpcclxuICAgICAgY2FzZSBEYXRhVHlwZS5VSW50MTY6XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuVUludDMyOlxyXG4gICAgICBjYXNlIERhdGFUeXBlLlVJbnQ2NDpcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIodmFsKTtcclxuICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobikgPyBNYXRoLnRydW5jKG4pIDogdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyh2YWwpO1xyXG4gICAgICBjYXNlIERhdGFUeXBlLkZsb2F0OlxyXG4gICAgICBjYXNlIERhdGFUeXBlLkRvdWJsZTpcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIGNvbnN0IG4gPSBOdW1iZXIodmFsKTtcclxuICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobikgPyBuIDogdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbCk7XHJcbiAgICAgIGNhc2UgRGF0YVR5cGUuU3RyaW5nOlxyXG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBPUENVQUhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU07RUFBRUEsV0FBVztFQUFFQyxZQUFZO0VBQUVDLG1CQUFtQjtFQUFFQyxjQUFjO0VBQUVDLE9BQU87RUFBRUMsZ0JBQWdCO0VBQUVDO0FBQVMsQ0FBQyxHQUFHQyxPQUFPLENBQUMsWUFBWSxDQUFDO0FBRXJJLE1BQU1DLFlBQVksQ0FBQztFQUNqQkMsV0FBV0EsQ0FBQ0MsWUFBWSxFQUFFQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQUU7SUFDckMsSUFBSSxDQUFDRCxZQUFZLEdBQUdBLFlBQVk7SUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUdBLE1BQU07SUFDcEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsSUFBSTtJQUNsQixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJO0lBQ25CLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEtBQUs7SUFDeEI7SUFDQSxJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJQyxHQUFHLENBQUMsQ0FBQztFQUM3QjtFQUVBLE1BQU1DLE9BQU9BLENBQUEsRUFBRztJQUNkLE1BQU1DLFdBQVcsR0FBRyxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sV0FBVztJQUMzQyxJQUFJLENBQUNBLFdBQVcsRUFBRSxNQUFNLElBQUlDLEtBQUssQ0FBQyxnQ0FBZ0MsQ0FBQztJQUVuRSxNQUFNUCxNQUFNLEdBQUdaLFdBQVcsQ0FBQ29CLE1BQU0sQ0FBQztNQUNoQ0MsZUFBZSxFQUFFLHVCQUF1QjtNQUN4Q0MsWUFBWSxFQUFFcEIsbUJBQW1CLENBQUNxQixJQUFJO01BQ3RDQyxjQUFjLEVBQUVyQixjQUFjLENBQUNvQixJQUFJO01BQ25DRSxpQkFBaUIsRUFBRSxLQUFLO01BQ3hCQyxrQkFBa0IsRUFBRTtRQUFFQyxZQUFZLEVBQUUsR0FBRztRQUFFQyxRQUFRLEVBQUU7TUFBRTtJQUN2RCxDQUFDLENBQUM7SUFFRixNQUFNQyxT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